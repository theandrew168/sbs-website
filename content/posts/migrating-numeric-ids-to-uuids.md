---
date: 2024-11-03
title: "Migrating Numeric IDs to UUIDs"
slug: "migrating-numeric-ids-to-uuids"
tags: ["Databases"]
---

There are a few ways to represent primary keys within a database.
The most common way (in my experience) to use auto-incrementing integers.
This means that first row's key will be 1, the second's will be 2, and so on.
When it comes to my preferred style of software development, this approach has a major downside: domain models must consult the database to determine their ID.

While I'm far from a [domain-driven design](https://en.wikipedia.org/wiki/Domain-driven_design) (DDD) purist, I like the idea of being able to represent the core domain objects and business logic of an application in complete isolation from the outside world.
Having domain objects depend on the database for IDs makes this impossible (or at least very difficult).
If only there existed a different kind of unique ID that could be generated by the domain objects themselves without requiring any coordination with an external system...

## UUIDs for Life

Enter the wonderful [Universally Unique Identifier](https://en.wikipedia.org/wiki/Universally_unique_identifier) (UUID).
These are random values that can be generated without coordination and are **extremely** unlikely to ever collide with another UUID.
This makes them a good candidate for database primary keys!
In fact, PostgreSQL has had native support for them [since version 8.3](https://www.postgresql.org/docs/8.3/release-8-3.html).
When starting a new project that requires a SQL database, I always default to using UUIDs for my primary keys.

They do have at least one downside compared to numeric IDs, though: they take up more space.
Integer primary keys typically occupy either 4 bytes (`serial`) or 8 bytes (`bigserial`) per key.
UUIDs, on the other hand, take up 16 bytes per ID (a 12 byte difference, potentially)!
Despite the increased size, I still think they are worth using simply due to the complexity they allow me to avoid when generating and working with domain objects in my application.

## The Big Migration

How do you migrate a database from numeric IDs to UUIDs?
If the data has no relationships, then the command is simple.
If there are relationships, however, then you need to utilize add intermediate values to the new table to track the old links and convert them to the new UUIDs.
This problem definitely gets more complex the larger your data model becomes.
At some point, it might not be worth it.
For Bloggulus, however, it was doable in a single, medium-complexity [migration](https://github.com/theandrew168/bloggulus/blob/main/migrations/0005_convert_ids_to_uuid.sql).

```sql
-- before
id SERIAL PRIMARY KEY

-- after
id UUID DEFAULT gen_random_uuid() PRIMARY KEY

-- easy case: without relationships
ALTER TABLE tag
	ALTER COLUMN id DROP DEFAULT,
	ALTER COLUMN id SET DATA TYPE UUID USING (gen_random_uuid()),
	ALTER COLUMN id SET DEFAULT gen_random_uuid();

ALTER TABLE migration
	ALTER COLUMN id DROP DEFAULT,
	ALTER COLUMN id SET DATA TYPE UUID USING (gen_random_uuid()),
	ALTER COLUMN id SET DEFAULT gen_random_uuid();

-- hard case: with relationships
-- create new parent table w/ UUID PK and old_id column
-- create new child table w/ UUID PK
-- populate new parent table (keep old ID around)
-- populate new child table (join to parent on old_id to get new UUID PK)
-- drop old_id column from parent
```

## Conclusion

I love using UUIDs for database primary keys.
Despite the extra space they occupy, they are more than worth the cost.
Being able to decouple domain object ID generation from the database allows me to write the largest and most critical aspects of my application in complete isolation from any other systems.
Originally, [Bloggulus](https://bloggulus.com/) was written with numeric primary keys.
I eventually wrote a migration (of moderate complexity) to convert them to UUIDs and haven't looked back.

Thanks for reading!
