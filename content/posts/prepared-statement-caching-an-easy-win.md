---
date: 2024-12-14
title: "Prepared Statement Caching: An Easy Win?"
slug: "prepared-statement-caching-an-easy-win"
tags: ["Databases"]
draft: true
---

In PostgreSQL, [prepared statements](https://www.postgresql.org/docs/current/sql-prepare.html) are a means of optimization for executing SQL queries.
Normally, SQL queries go through [multiple phases](https://www.postgresql.org/docs/current/query-path.html) of processing before being executed: parsing, rewriting, and planning.
If your program executes the same query multiple times (as applications often do), then reperforming all of these steps each time is a bit redundant.
By "preparing" the statement ahead of time, you can parse and rewrite the query one and reuse the results.
This means that a prepared statement only needs to be planned before execution.

PostgreSQL client libraries often expose a manual API for preparing and executing statements.
This allows you, as a programmer, to be intentional about where and when to utilize this optimization.
However, since _most_ queries in an application end up being executed more than once, it'd be nice if the client library could automatically and transparently prepare and cache SQL statements under the hood.
Well, I have some good news for you!
Many libraries _can_ and _do_ do this.

For example, the Java [JDBC](https://jdbc.postgresql.org/documentation/server-prepare/#activation) driver, the Go [pgx](https://github.com/jackc/pgx/wiki/Automatic-Prepared-Statement-Caching) driver, the NodeJS [Postgres.js](https://github.com/porsager/postgres?tab=readme-ov-file#prepared-statements) driver, and the Python [psycopg2](https://www.psycopg.org/psycopg3/docs/advanced/prepare.html) and [asyncpg](https://magicstack.github.io/asyncpg/current/api/index.html#prepared-statements) drivers all support prepared statement caching.
They all even enable it by default!
Some other client libraries, however, _don't_ include this automatic caching behavior.
The [node-postgres](https://node-postgres.com/features/queries#prepared-statements) library, for example, supports prepared statement caching but you have to intentionally generate and provide a unique `name` parameter when executing queries.
Thankfully, unique names can be easily generated by hashing the raw, parameterized SQL.

When implemented correctly, the application users (and database admins) benefit from faster, cheaper queries essentially for free.
That being said, are there any reasons to _not_ implement and utilize automated prepared statement caching?
Based on my lived experience (and research) there is at least one downside: some PostgreSQL proxies don't support prepared statements.
One of the most popular database proxies, [PgBouncer](https://www.pgbouncer.org/) didn't support prepared statements until [version 1.12.0](https://www.postgresql.org/about/news/pgbouncer-1210-released-now-with-prepared-statements-2735/) which released in October 2023.

So, in the event that your database is deployed behind a proxy that doesn't support prepared statements, your application won't be able to reap these benefits.
But for everyone else, enjoy your free performance boost!
