<!doctype html><html lang=en><head><title>Migrating Numeric IDs to UUIDs · Shallow Brook Software
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Andrew Dailey"><meta name=description content="There are a few ways to represent primary keys within a database.
The most common way (in my experience) to use auto-incrementing integers.
This means that first row&rsquo;s key will be 1, the second&rsquo;s will be 2, and so on.
When it comes to my preferred style of software development, however, this approach has a major downside: new domain objects must first consult the database to determine their ID.
While I&rsquo;m far from a domain-driven design (DDD) purist, I like the idea of being able to represent the core domain objects and business logic of an application in complete isolation from the outside world.
Having domain objects depend on the database for IDs makes this impossible (or at least very difficult).
If only there existed a different kind of unique ID that could be generated by the domain objects themselves without requiring any coordination with an external system&mldr;"><meta name=keywords content="blog,developer,personal"><meta name=fediverse:creator content><meta name=twitter:card content="summary"><meta name=twitter:title content="Migrating Numeric IDs to UUIDs"><meta name=twitter:description content="There are a few ways to represent primary keys within a database. The most common way (in my experience) to use auto-incrementing integers. This means that first row’s key will be 1, the second’s will be 2, and so on. When it comes to my preferred style of software development, however, this approach has a major downside: new domain objects must first consult the database to determine their ID.
While I’m far from a domain-driven design (DDD) purist, I like the idea of being able to represent the core domain objects and business logic of an application in complete isolation from the outside world. Having domain objects depend on the database for IDs makes this impossible (or at least very difficult). If only there existed a different kind of unique ID that could be generated by the domain objects themselves without requiring any coordination with an external system…"><meta property="og:url" content="https://shallowbrooksoftware.com/posts/migrating-numeric-ids-to-uuids/"><meta property="og:site_name" content="Shallow Brook Software"><meta property="og:title" content="Migrating Numeric IDs to UUIDs"><meta property="og:description" content="There are a few ways to represent primary keys within a database. The most common way (in my experience) to use auto-incrementing integers. This means that first row’s key will be 1, the second’s will be 2, and so on. When it comes to my preferred style of software development, however, this approach has a major downside: new domain objects must first consult the database to determine their ID.
While I’m far from a domain-driven design (DDD) purist, I like the idea of being able to represent the core domain objects and business logic of an application in complete isolation from the outside world. Having domain objects depend on the database for IDs makes this impossible (or at least very difficult). If only there existed a different kind of unique ID that could be generated by the domain objects themselves without requiring any coordination with an external system…"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-03T00:00:00+00:00"><meta property="article:modified_time" content="2024-11-03T00:00:00+00:00"><meta property="article:tag" content="Databases"><link rel=canonical href=https://shallowbrooksoftware.com/posts/migrating-numeric-ids-to-uuids/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.e927f7340e309d76dcb8fda85f1531ae7341aa9cd0b7f3ab77885dae77b1a0a2.css integrity="sha256-6Sf3NA4wnXbcuP2oXxUxrnNBqpzQt/Ord4hdrnexoKI=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://shallowbrooksoftware.com/>Shallow Brook Software
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://shallowbrooksoftware.com/posts/migrating-numeric-ids-to-uuids/>Migrating Numeric IDs to UUIDs</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2024-11-03T00:00:00Z>November 3, 2024
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
6-minute read</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/databases/>Databases</a></span></div></div></header><div class=post-content><p>There are a few ways to represent primary keys within a database.
The most common way (in my experience) to use auto-incrementing integers.
This means that first row&rsquo;s key will be 1, the second&rsquo;s will be 2, and so on.
When it comes to my preferred style of software development, however, this approach has a major downside: new domain objects must first consult the database to determine their ID.</p><p>While I&rsquo;m far from a <a href=https://en.wikipedia.org/wiki/Domain-driven_design class=external-link target=_blank rel=noopener>domain-driven design</a> (DDD) purist, I like the idea of being able to represent the core domain objects and business logic of an application in complete isolation from the outside world.
Having domain objects depend on the database for IDs makes this impossible (or at least very difficult).
If only there existed a different kind of unique ID that could be generated by the domain objects themselves without requiring any coordination with an external system&mldr;</p><h2 id=uuids-for-life>UUIDs for Life
<a class=heading-link href=#uuids-for-life><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Enter the wonderful <a href=https://en.wikipedia.org/wiki/Universally_unique_identifier class=external-link target=_blank rel=noopener>Universally Unique Identifier</a> (UUID).
These are random values that can be generated without coordination and are <strong>extremely</strong> unlikely to ever collide with another.
This makes them a good candidate for database primary keys!
In fact, PostgreSQL has had native support for them <a href=https://www.postgresql.org/docs/8.3/release-8-3.html class=external-link target=_blank rel=noopener>since version 8.3</a>.
When starting a new project that requires a SQL database, I always default to using UUIDs for primary keys.</p><p>They do have at least one downside compared to numeric IDs, though: they take up more space.
Integer primary keys typically occupy either 4 bytes (<code>serial</code>) or 8 bytes (<code>bigserial</code>) per key.
UUIDs, on the other hand, take up 16 bytes per ID (a 12 byte difference, potentially)!
Despite the increased size, I still think they are worth using simply due to the complexity they absolve when generating and working with domain objects.</p><h2 id=the-big-migration>The Big Migration
<a class=heading-link href=#the-big-migration><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>UUIDs are great, so what&rsquo;s the problem?
Where is the &ldquo;migration&rdquo; mentioned in this post&rsquo;s title?
Well, prior to learning about DDD and embracing the magic of UUIDs, <a href=https://bloggulus.com/ class=external-link target=_blank rel=noopener>Bloggulus</a> was written with numeric primary keys.
I wanted to change them but there was a snag: my database was already tracking tens of blogs and hundreds of posts.
Therefore, I didn&rsquo;t want to wipe the database and start from scratch: I needed to migrate it in-place.
Here is what the schema looked like at the start:</p><p><img src=/images/20241103/schema.webp alt="The schema of Bloggulus with four tables"></p><p>Things were pretty simple back then.
These days, Bloggulus has eight tables!
It&rsquo;s certainly not a massive system but still enough to keep me busy.</p><p>Anyhow, back to the migration.
In short, what we need to do is this: convert every numeric primary key column into a UUID:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- before
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>id SERIAL <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- after
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>id UUID <span style=color:#66d9ef>DEFAULT</span> gen_random_uuid() <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>
</span></span></code></pre></div><p>How can we make this happen?
It actually depends on whether or not you have to worry about relationships.
The goal of &ldquo;convert every numeric primary key column into a UUID&rdquo; implies a knock-on effect: foreign keys also need to be converted to UUIDs while pointing to the same, original row in the other table.
My migration also has an extra, self-imposed, and somewhat unnecessary requirement: <strong>I still want the each table&rsquo;s primary key to be the first column</strong>.</p><h2 id=easy-case-no-relationships>Easy Case: No Relationships
<a class=heading-link href=#easy-case-no-relationships><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>If the data has no relationships, then the command is simple: use <a href=https://www.postgresql.org/docs/current/sql-altertable.html class=external-link target=_blank rel=noopener>ALTER TABLE</a> to directly swap the column&rsquo;s type.
This requires a bit of nuance, though, with respect to defaults.
The primary key column&rsquo;s default must be dropped before swapping the type and then re-established afterward.
Lastly, we use <a href=https://www.postgresql.org/docs/current/functions-uuid.html class=external-link target=_blank rel=noopener>gen_random_uuid</a> to generate a fresh UUID for each row.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- Modify the tag.id column in place.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> tag
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>COLUMN</span> id <span style=color:#66d9ef>DROP</span> <span style=color:#66d9ef>DEFAULT</span>,
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>COLUMN</span> id <span style=color:#66d9ef>SET</span> <span style=color:#66d9ef>DATA</span> <span style=color:#66d9ef>TYPE</span> UUID <span style=color:#66d9ef>USING</span> (gen_random_uuid()),
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>COLUMN</span> id <span style=color:#66d9ef>SET</span> <span style=color:#66d9ef>DEFAULT</span> gen_random_uuid();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- Modify the migration.id column in place.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> migration
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>COLUMN</span> id <span style=color:#66d9ef>DROP</span> <span style=color:#66d9ef>DEFAULT</span>,
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>COLUMN</span> id <span style=color:#66d9ef>SET</span> <span style=color:#66d9ef>DATA</span> <span style=color:#66d9ef>TYPE</span> UUID <span style=color:#66d9ef>USING</span> (gen_random_uuid()),
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>COLUMN</span> id <span style=color:#66d9ef>SET</span> <span style=color:#66d9ef>DEFAULT</span> gen_random_uuid();
</span></span></code></pre></div><h2 id=hard-case-with-relationships>Hard Case: With Relationships
<a class=heading-link href=#hard-case-with-relationships><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>If there are relationships, however, then a few more steps must be taken.
Instead of modifying the tables in place, we need to create new tables and carefully copy the existing data such that we don&rsquo;t lose track of the foreign keys.
More specifically, we need to temporarily persist the original IDs of the &ldquo;parent&rdquo; table so that the &ldquo;child&rdquo; table&rsquo;s rows can be linked to the parent&rsquo;s new UUIDs.</p><p>Perhaps things will be clearer if we look at a real example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- Create the new &#34;parent&#34; table w/ UUID primary key and temporary original_id column.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> blog_new (
</span></span><span style=display:flex><span>	id UUID <span style=color:#66d9ef>DEFAULT</span> gen_random_uuid() <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>,
</span></span><span style=display:flex><span>	feed_url TEXT <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>UNIQUE</span>,
</span></span><span style=display:flex><span>	site_url TEXT <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>	title TEXT <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>	etag TEXT <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>DEFAULT</span> <span style=color:#e6db74>&#39;&#39;</span>,
</span></span><span style=display:flex><span>	last_modified TEXT <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>DEFAULT</span> <span style=color:#e6db74>&#39;&#39;</span>,
</span></span><span style=display:flex><span>	synced_at TIMESTAMPTZ <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>DEFAULT</span> now(),
</span></span><span style=display:flex><span>	created_at TIMESTAMPTZ <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>DEFAULT</span> now(),
</span></span><span style=display:flex><span>	updated_at TIMESTAMPTZ <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>DEFAULT</span> now(),
</span></span><span style=display:flex><span>	<span style=color:#75715e>-- temporary
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	original_id INTEGER
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- Create the new &#34;child&#34; table w/ UUID primary key.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> post_new (
</span></span><span style=display:flex><span>	id UUID <span style=color:#66d9ef>DEFAULT</span> gen_random_uuid() <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>,
</span></span><span style=display:flex><span>	blog_id UUID <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>	url TEXT <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>UNIQUE</span>,
</span></span><span style=display:flex><span>	title TEXT <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>	content TEXT <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>	published_at TIMESTAMPTZ <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>	fts_data TSVECTOR <span style=color:#66d9ef>GENERATED</span> ALWAYS <span style=color:#66d9ef>AS</span>
</span></span><span style=display:flex><span>		(to_tsvector(<span style=color:#e6db74>&#39;english&#39;</span>, title <span style=color:#f92672>||</span> <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#f92672>||</span> content)) STORED,
</span></span><span style=display:flex><span>	created_at TIMESTAMPTZ <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>DEFAULT</span> now(),
</span></span><span style=display:flex><span>	updated_at TIMESTAMPTZ <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>DEFAULT</span> now()
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- Populate the new parent table while keeping the original_id around.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> blog_new
</span></span><span style=display:flex><span>	(feed_url, site_url, title, etag, last_modified, original_id)
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span>
</span></span><span style=display:flex><span>	blog.feed_url,
</span></span><span style=display:flex><span>	blog.site_url,
</span></span><span style=display:flex><span>	blog.title,
</span></span><span style=display:flex><span>	blog.etag,
</span></span><span style=display:flex><span>	blog.last_modified,
</span></span><span style=display:flex><span>	<span style=color:#75715e>-- original_id
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	blog.id
</span></span><span style=display:flex><span><span style=color:#66d9ef>FROM</span> blog;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- Populate the new child table while joining to the parent (based on
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- its original_id) to obtain the parent&#39;s new UUID primary key.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> post_new
</span></span><span style=display:flex><span>	(blog_id, url, title, content, published_at)
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span>
</span></span><span style=display:flex><span>	blog_new.id,
</span></span><span style=display:flex><span>	post.url,
</span></span><span style=display:flex><span>	post.title,
</span></span><span style=display:flex><span>	post.body,
</span></span><span style=display:flex><span>	post.updated
</span></span><span style=display:flex><span><span style=color:#66d9ef>FROM</span> post
</span></span><span style=display:flex><span><span style=color:#66d9ef>INNER</span> <span style=color:#66d9ef>JOIN</span> blog_new
</span></span><span style=display:flex><span>	<span style=color:#75715e>-- Join on the blog&#39;s original_id.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>ON</span> blog_new.original_id <span style=color:#f92672>=</span> post.blog_id;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- Drop the temporary original_id column from the parent.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> blog_new <span style=color:#66d9ef>DROP</span> <span style=color:#66d9ef>COLUMN</span> original_id;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- Extra cleanup omitted for brevity:
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- 1. Drop old tables.
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- 2. Rename new tables.
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- 3. Rename new table indexes (the auto-generated ones).
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- 4. Add indexes to new tables (the manual ones).
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- 5. Reapply foreign key constraints.
</span></span></span></code></pre></div><p>There we go!
That was certainly a lot of SQL.
I hope that seeing an example makes the process a bit more clear but I apologize if I haven&rsquo;t done a great job explaining how this works.
If you want to see the full migration complete with all of the nuances, <a href=https://github.com/theandrew168/bloggulus/blob/main/migrations/0005_convert_ids_to_uuid.sql class=external-link target=_blank rel=noopener>take a look</a>.</p><p>I&rsquo;ll say this: the problem of tracking and joining on the original IDs definitely gets more complex the larger your data model becomes.
At some scale, I think things could quickly get out of hand.
I got luckly, though, and merely had to deal with the simplest of relationships between only two tables.</p><h2 id=conclusion>Conclusion
<a class=heading-link href=#conclusion><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>I love using UUIDs for database primary keys.
Despite the extra space they occupy, they are more than worth the cost.
Being able to decouple domain object ID generation from the database allows me to write the largest and most critical aspects of my application in complete isolation from other systems.
Originally, <a href=https://bloggulus.com/ class=external-link target=_blank rel=noopener>Bloggulus</a> was written with numeric primary keys.
This limited my ability to explore the concepts of domain-driven design.
I eventually wrote a migration of moderate complexity to convert them to UUIDs and haven&rsquo;t looked back.</p><p>Thanks for reading!</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2025
Andrew Dailey
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script data-goatcounter=https://shallowbrooksoftware.goatcounter.com/count async src=//gc.zgo.at/count.js></script></body></html>