<!doctype html><html lang=en><head><title>Reinforcing Indirect Joins · Shallow Brook Software
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Andrew Dailey"><meta name=description content="Recently, I ran into an issue where a very large PostgreSQL query (involving roughly 30 tables) was taking much longer to plan than to execute.
At its worst, it was taking multiple seconds to plan and a few hundred milliseconds to execute.
My problem wasn&rsquo;t really about standard query optimization: I was already past that.
This was a problem of query complexity and trying to get the PostgreSQL planner/optimizer to more quickly arrive at an ideal query."><meta name=keywords content="blog,developer,personal"><meta name=fediverse:creator content><meta name=twitter:card content="summary"><meta name=twitter:title content="Reinforcing Indirect Joins"><meta name=twitter:description content="Recently, I ran into an issue where a very large PostgreSQL query (involving roughly 30 tables) was taking much longer to plan than to execute. At its worst, it was taking multiple seconds to plan and a few hundred milliseconds to execute. My problem wasn’t really about standard query optimization: I was already past that. This was a problem of query complexity and trying to get the PostgreSQL planner/optimizer to more quickly arrive at an ideal query."><meta property="og:url" content="https://shallowbrooksoftware.com/posts/reinforcing-indirect-joins/"><meta property="og:site_name" content="Shallow Brook Software"><meta property="og:title" content="Reinforcing Indirect Joins"><meta property="og:description" content="Recently, I ran into an issue where a very large PostgreSQL query (involving roughly 30 tables) was taking much longer to plan than to execute. At its worst, it was taking multiple seconds to plan and a few hundred milliseconds to execute. My problem wasn’t really about standard query optimization: I was already past that. This was a problem of query complexity and trying to get the PostgreSQL planner/optimizer to more quickly arrive at an ideal query."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-06-16T00:00:00+00:00"><meta property="article:modified_time" content="2024-06-16T00:00:00+00:00"><meta property="article:tag" content="Databases"><link rel=canonical href=https://shallowbrooksoftware.com/posts/reinforcing-indirect-joins/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.e927f7340e309d76dcb8fda85f1531ae7341aa9cd0b7f3ab77885dae77b1a0a2.css integrity="sha256-6Sf3NA4wnXbcuP2oXxUxrnNBqpzQt/Ord4hdrnexoKI=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://shallowbrooksoftware.com/>Shallow Brook Software
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://shallowbrooksoftware.com/posts/reinforcing-indirect-joins/>Reinforcing Indirect Joins</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2024-06-16T00:00:00Z>June 16, 2024
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
5-minute read</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/databases/>Databases</a></span></div></div></header><div class=post-content><p>Recently, I ran into an issue where a very large PostgreSQL query (involving roughly 30 tables) was taking much longer to plan than to execute.
At its worst, it was taking multiple <em>seconds</em> to plan and a few hundred milliseconds to execute.
My problem wasn&rsquo;t really about standard query optimization: I was already past that.
This was a problem of query complexity and trying to get the PostgreSQL <a href=https://www.postgresql.org/docs/current/planner-optimizer.html class=external-link target=_blank rel=noopener>planner/optimizer</a> to more quickly arrive at an ideal query.</p><h1 id=research>Research
<a class=heading-link href=#research><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>Early research made me realize that there is much less content to be found on this specific topic.
There are endless articles explaining how to speed up a query&rsquo;s <em>execution</em> with tools like indexes and clustering.
However, reading material surrounding speeding up the planner/optimizer itself is much more rare.</p><p>I was at least able to find some <a href=https://www.postgresql.eu/events/pgconfeu2017/sessions/session/1617/slides/9/FromMinutesToMilliseconds.pdf class=external-link target=_blank rel=noopener>slides from a presentation</a> at the PostgreSQL Conference Europe 2017 that pointed me in the right direction.
I started by messing around with some planner tweaks (like <a href=https://www.postgresql.org/docs/current/runtime-config-query.html#GUC-JOIN-COLLAPSE-LIMIT class=external-link target=_blank rel=noopener>join_collapse_limit</a>) which did help a bit but didn&rsquo;t completely solve my problem: planning was still the query&rsquo;s bottleneck.</p><p>I decided to try a new strategy.
I reassembled the query join by join and measured how long the planner/optimizer took at every step.
Once the planning time eventually jumped, I took a moment to think about the data model and how the tables were being joined.
I eventually noticed a pattern that was causing the planner to take extra time and even came up with a name for the fix: <strong>reinforcing indirect joins</strong>.</p><h1 id=an-example>An Example
<a class=heading-link href=#an-example><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>I&rsquo;ll try to explain this concept with an example.
Consider a simple schema with three tables: <code>post</code>, <code>tag</code>, and <code>comment</code>.
One post can have many tags and many comments.
Therefore, both the <code>tag</code> and <code>comment</code> tables have a foreign key reference back to <code>post</code>.</p><p><img src=/images/20240616/schema.webp alt="Simple schema for posts, tags, and comments"></p><p>Now, perhaps you are in a position to ask questions about the relationship between tags and comments.
Do posts with certain tags attract more comments than others?
Are some tags associated with positive sentiment and others with negative?
To start gathering data and answering these questions, you dive into the SQL.
Since you only really care about tags and comments and they can be easily linked together (via <code>post_id</code>), let&rsquo;s get it done:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>select</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;tag&#34;</span>.<span style=color:#e6db74>&#34;name&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;comment&#34;</span>.<span style=color:#e6db74>&#34;message&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#34;tag&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>inner</span> <span style=color:#66d9ef>join</span> <span style=color:#e6db74>&#34;comment&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>on</span> <span style=color:#e6db74>&#34;comment&#34;</span>.<span style=color:#e6db74>&#34;post_id&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;tag&#34;</span>.<span style=color:#e6db74>&#34;post_id&#34;</span>;
</span></span></code></pre></div><h1 id=the-problem>The Problem
<a class=heading-link href=#the-problem><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>Now, based on my what I&rsquo;ve seen and experienced, we&rsquo;ve just thrown a curveball at the planner/optimizer.
The tables <code>tag</code> and <code>comment</code> are indirectly linked to each other: they link to each other &ldquo;through&rdquo; the <code>post</code> table.
Despite this indirect join returning the correct data, PostgreSQL may have trouble deciding how best to optimally execute the query.
With large enough queries, this type of short-cutting can lead to the planner/optimizer taking way longer than expected.</p><p>What can we do about it?
Well, we can take this indirect join and reinforce it!</p><h1 id=the-solution>The Solution
<a class=heading-link href=#the-solution><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>The solution is actually quite simple: add a join to the &ldquo;missing link&rdquo; table even if you don&rsquo;t need any data from it.
Here&rsquo;s what the fix looks this looks for our current example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>select</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;tag&#34;</span>.<span style=color:#e6db74>&#34;name&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;comment&#34;</span>.<span style=color:#e6db74>&#34;message&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#34;tag&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- join from &#34;tag&#34; to &#34;comment&#34; through &#34;post&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>inner</span> <span style=color:#66d9ef>join</span> <span style=color:#e6db74>&#34;post&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>on</span> <span style=color:#e6db74>&#34;post&#34;</span>.<span style=color:#e6db74>&#34;id&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;tag&#34;</span>.<span style=color:#e6db74>&#34;post_id&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>inner</span> <span style=color:#66d9ef>join</span> <span style=color:#e6db74>&#34;comment&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>on</span> <span style=color:#e6db74>&#34;comment&#34;</span>.<span style=color:#e6db74>&#34;post_id&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;post&#34;</span>.<span style=color:#e6db74>&#34;id&#34;</span>;
</span></span></code></pre></div><p>To be honest, I&rsquo;m not exactly sure <em>why</em> this helps, but I have a guess.
PostgreSQL only understands (from a statistics point of view) the relationships between two individual tables.
It knows hows tags relate to posts and how comments relate to posts, but not how tags relate to comments.
By adding posts into the query, the planner/optimizer is able to say &ldquo;Ahh, I understand: they want the comments assocated with this tag&rsquo;s post&rdquo;.</p><p>Perhaps, without the extra join, the database has to search through more plans and therefore takes longer to find one that is optimal.</p><h1 id=another-example>Another Example
<a class=heading-link href=#another-example><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>Another sneaky way that this problem can manifest is when using CTEs to build smaller subsets of data into a larger response.
Maybe you were first querying for tags that meet a certain condition before joining to comments:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- build a CTE of relevant tags
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>with</span> <span style=color:#e6db74>&#34;relevant_tag&#34;</span> <span style=color:#66d9ef>as</span> (
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#34;tag&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>where</span> <span style=color:#e6db74>&#34;tag&#34;</span>.<span style=color:#e6db74>&#34;name&#34;</span> <span style=color:#66d9ef>ilike</span> <span style=color:#e6db74>&#39;golang&#39;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>select</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;relevant_tag&#34;</span>.<span style=color:#e6db74>&#34;name&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;comment&#34;</span>.<span style=color:#e6db74>&#34;message&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- find comments related to the relevant tags
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#34;relevant_tag&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>inner</span> <span style=color:#66d9ef>join</span> <span style=color:#e6db74>&#34;comment&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>on</span> <span style=color:#e6db74>&#34;comment&#34;</span>.<span style=color:#e6db74>&#34;post_id&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;tag&#34;</span>.<span style=color:#e6db74>&#34;post_id&#34;</span>;
</span></span></code></pre></div><p>Despite having more SQL here to make the relationships slightly less clear, the same problem can occur: PostgreSQL doesn&rsquo;t understand how tags relate to comments.
Thankfully, the fix is the same: just reinforce the indirect join by adding the missing link:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>with</span> <span style=color:#e6db74>&#34;relevant_tag&#34;</span> <span style=color:#66d9ef>as</span> (
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#34;tag&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>where</span> <span style=color:#e6db74>&#34;tag&#34;</span>.<span style=color:#e6db74>&#34;name&#34;</span> <span style=color:#66d9ef>ilike</span> <span style=color:#e6db74>&#39;golang&#39;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>select</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;relevant_tag&#34;</span>.<span style=color:#e6db74>&#34;name&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;comment&#34;</span>.<span style=color:#e6db74>&#34;message&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#34;relevant_tag&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- join from &#34;relevant_tag&#34; to &#34;comment&#34; through &#34;post&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>inner</span> <span style=color:#66d9ef>join</span> <span style=color:#e6db74>&#34;post&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>on</span> <span style=color:#e6db74>&#34;post&#34;</span>.<span style=color:#e6db74>&#34;id&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;relevant_tag&#34;</span>.<span style=color:#e6db74>&#34;post_id&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>inner</span> <span style=color:#66d9ef>join</span> <span style=color:#e6db74>&#34;comment&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>on</span> <span style=color:#e6db74>&#34;comment&#34;</span>.<span style=color:#e6db74>&#34;post_id&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;post&#34;</span>.<span style=color:#e6db74>&#34;id&#34;</span>;
</span></span></code></pre></div><h1 id=conclusion>Conclusion
<a class=heading-link href=#conclusion><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>There you have it!
If you ever run into large queries with slow plan times, consider checking for (and reinforcing) any indirect joins.
For smaller queries (like the examples in this post), the planner/optimizer is unlikely to be a bottleneck.
In my experience, this problem only occurs on extra large queries with many tables being joined together.
This could also be a problem that only arose due the specific data model and statistics of the database that I was working with.</p><p>At the end of the day, I wish I had been able to find more information about why this slowdown occurs.
I really want to understand why this happens and if anything else can be done to &ldquo;tell&rdquo; PostgreSQL about these indirect relationships between tables.
Perhaps this is simply common knowledge: only join on columns that properly reference each other.
Either way, this experience taught me a lesson that I won&rsquo;t soon forget.</p><p>Thanks for reading!</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2025
Andrew Dailey
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script data-goatcounter=https://shallowbrooksoftware.goatcounter.com/count async src=//gc.zgo.at/count.js></script></body></html>