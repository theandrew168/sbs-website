<!doctype html><html lang=en><head><title>Simple REST API Pagination · Shallow Brook Software
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Andrew Dailey"><meta name=description content="Recently, I&rsquo;ve been working on revamping my Bloggulus project to a split REST API + SPA architecture (for fun and as an excuse to learn SvelteKit). As a part of this effort, I took a moment to research and revisit how the API handles pagination. Since the system holds hundreds of blogs and thousands of posts, returning all items from a request would be slow and unwieldy. Instead, the user (or web frontend) should be allowed to specify which set of items they want to view."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Simple REST API Pagination"><meta name=twitter:description content="Recently, I&rsquo;ve been working on revamping my Bloggulus project to a split REST API + SPA architecture (for fun and as an excuse to learn SvelteKit). As a part of this effort, I took a moment to research and revisit how the API handles pagination. Since the system holds hundreds of blogs and thousands of posts, returning all items from a request would be slow and unwieldy. Instead, the user (or web frontend) should be allowed to specify which set of items they want to view."><meta property="og:title" content="Simple REST API Pagination"><meta property="og:description" content="Recently, I&rsquo;ve been working on revamping my Bloggulus project to a split REST API + SPA architecture (for fun and as an excuse to learn SvelteKit). As a part of this effort, I took a moment to research and revisit how the API handles pagination. Since the system holds hundreds of blogs and thousands of posts, returning all items from a request would be slow and unwieldy. Instead, the user (or web frontend) should be allowed to specify which set of items they want to view."><meta property="og:type" content="article"><meta property="og:url" content="https://shallowbrooksoftware.com/posts/simple-rest-api-pagination/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-04-14T22:00:00+00:00"><meta property="article:modified_time" content="2024-04-14T22:00:00+00:00"><link rel=canonical href=https://shallowbrooksoftware.com/posts/simple-rest-api-pagination/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.577e3c5ead537873430da16f0964b754a120fd87c4e2203a00686e7c75b51378.css integrity="sha256-V348Xq1TeHNDDaFvCWS3VKEg/YfE4iA6AGhufHW1E3g=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://shallowbrooksoftware.com/>Shallow Brook Software
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://shallowbrooksoftware.com/posts/simple-rest-api-pagination/>Simple REST API Pagination</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2024-04-14T22:00:00Z>April 14, 2024
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
5-minute read</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/go/>Go</a></span></div></div></header><div class=post-content><p>Recently, I&rsquo;ve been working on revamping my <a href=https://github.com/theandrew168/bloggulus class=external-link target=_blank rel=noopener>Bloggulus</a> project to a split <a href=https://developer.mozilla.org/en-US/docs/Glossary/REST class=external-link target=_blank rel=noopener>REST API</a> + <a href=https://developer.mozilla.org/en-US/docs/Glossary/SPA class=external-link target=_blank rel=noopener>SPA</a> architecture (for fun and as an excuse to learn <a href=https://kit.svelte.dev/ class=external-link target=_blank rel=noopener>SvelteKit</a>).
As a part of this effort, I took a moment to research and revisit how the API handles pagination.
Since the system holds hundreds of blogs and thousands of posts, returning <em>all</em> items from a request would be slow and unwieldy.
Instead, the user (or web frontend) should be allowed to specify which set of items they want to view.
This is where pagination comes into play.</p><p>Before I go any further, I want to give a special shoutout to Tania Rascia&rsquo;s <a href=https://www.taniarascia.com/ class=external-link target=_blank rel=noopener>blog</a> and her <a href=https://www.taniarascia.com/rest-api-sorting-filtering-pagination/ class=external-link target=_blank rel=noopener>post</a> about REST API design.
She has one of the best blogs on the internet and I always find myself coming back to it.
Thanks, Tania!</p><h1 id=pagination>Pagination
<a class=heading-link href=#pagination><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>Pagination is the process of splitting up a large set of results into smaller, individual &ldquo;pages&rdquo;.
Let&rsquo;s use Bloggulus&rsquo; concept of &ldquo;posts&rdquo; as an example.
By default, the system will return the most recent 20 posts if you call <code>GET /api/v1/posts</code>.
What if, instead, you want the <em>second</em> page of results?
Or maybe you only want to see 15 posts instead of 20.
How can we tell the server to only give us a specific subset of posts?</p><p>There are two common approaches but they have one thing in common: <strong>results must have a consistent and deterministic ordering</strong>.
Whether you choose to order results alphabetically, chronologically, or by some other means, the order must be consistent for pagination to work correctly.</p><h1 id=limit-and-offset>Limit and Offset
<a class=heading-link href=#limit-and-offset><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>The first approach is somewhat &ldquo;no-frills&rdquo; and feels a bit like &ldquo;computer speak&rdquo;.
Instead of even bothering with the word &ldquo;page&rdquo;, just think like a database and use the terms &ldquo;limit&rdquo; and &ldquo;offset&rdquo;.
With this tactic, &ldquo;limit&rdquo; refers to how items you want to fetch and &ldquo;offset&rdquo; refers to how many items you want to skip before fetching the &ldquo;limit&rdquo; number of items.
Using the two examples from before, let&rsquo;s see how you&rsquo;d achieve them using this technique:</p><table><thead><tr><th>Second Page of 20</th><th>First Page of 15</th></tr></thead><tbody><tr><td><code>GET /api/v2/posts?limit=20&amp;offset=20</code></td><td><code>GET /api/v2/posts?limit=15&amp;offset=0</code></td></tr></tbody></table><p>Note that in this scenario, most APIs implement a default for both values.
In our current example, the default &ldquo;limit&rdquo; and &ldquo;offset&rdquo; are 20 and 0 (respectively) meaning that we can simplify our requests a bit:</p><table><thead><tr><th>Second Page of 20</th><th>First Page of 15</th></tr></thead><tbody><tr><td><code>GET /api/v2/posts?offset=20</code></td><td><code>GET /api/v2/posts?limit=15</code></td></tr></tbody></table><p>Overall, this approach works just fine and can handle all pagination needs.
The main downside, however, is user experience.
For example, if you want to iterate through all pages of results, you&rsquo;ll have to compute each page&rsquo;s offset yourself: <code>offset = (page - 1) * limit</code>.
Additionally, &ldquo;limit&rdquo; and &ldquo;offset&rdquo; aren&rsquo;t the most natural terms to describe this concept.
It might be more straightforward to think about things a bit more literally.</p><h1 id=page-and-size>Page and Size
<a class=heading-link href=#page-and-size><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>Instead of thinking about this problem like a database, let&rsquo;s think about it like actual pages (it <em>is</em> called pagination, after all).
We&rsquo;ll swap out &ldquo;limilt&rdquo; and &ldquo;offset&rdquo; for two new values: &ldquo;page&rdquo; and &ldquo;size&rdquo;.
Here, &ldquo;page&rdquo; refers to the page of results you want to view and defaults to 1 in most REST APIs.
The other value, &ldquo;size&rdquo;, refers to the number of results per page and defaults to 20 in this example (but will likely be different for different APIs).</p><p>Let&rsquo;s see how the requests look now:</p><table><thead><tr><th>Second Page of 20</th><th>First Page of 15</th></tr></thead><tbody><tr><td><code>GET /api/v2/posts?page=2</code></td><td><code>GET /api/v2/posts?size=15</code></td></tr></tbody></table><p>I find this to be bit more readable!
In the common case where users want the next page of results, they just increment &ldquo;page&rdquo;.
If they <em>do</em> want to utilize a different page size, they can simply change the &ldquo;size&rdquo;.
Even with different page sizes, the &ldquo;page&rdquo; value will continue to work in the same way and enable easy page indexing.
The user won&rsquo;t have to do any special math in order to target the correct range of values.</p><p>That being said, <em>someone</em> has to do the math to convert from &ldquo;page&rdquo; and &ldquo;size&rdquo; to &ldquo;limit&rdquo; and &ldquo;offset&rdquo;.
This is because, on the backend, the database still works in terms of the latter.
We saw part of this conversion earlier but I&rsquo;ll write both parts here:</p><pre tabindex=0><code>limit = size
offset = (page - 1) * limit
</code></pre><p>My backend is written in Go and the math transfers to code quite literally.
Here&rsquo;s a helper I wrote to handle the conversion:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Convert user-friendly &#34;page/size&#34; pagination to DB-friendly &#34;limit/offset&#34;.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>PageSizeToLimitOffset</span>(<span style=color:#a6e22e>page</span>, <span style=color:#a6e22e>size</span> <span style=color:#66d9ef>int</span>) (<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>limit</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>size</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>offset</span> <span style=color:#f92672>:=</span> (<span style=color:#a6e22e>page</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> <span style=color:#a6e22e>limit</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>limit</span>, <span style=color:#a6e22e>offset</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=conclusion>Conclusion
<a class=heading-link href=#conclusion><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>This post outlined the need for pagination in REST APIs and explored two techniques for describing specific pages.
While &ldquo;limit&rdquo; and &ldquo;offset&rdquo; map more cleanly to underlying databases, &ldquo;page&rdquo; and &ldquo;size&rdquo; are a bit more user-friendly and defer some the calculations to the server.
In the wild, you&rsquo;ll probably see more terms than just the four mentioned here.
Some APIs use more descriptive names like &ldquo;results_per_page&rdquo; or &ldquo;page_size&rdquo; but the concepts are generally the same.
Thanks for reading!</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2024
Andrew Dailey
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>