<!doctype html><html lang=en><head><title>A Parallel ForEach Implementation in Go · Shallow Brook Software
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Andrew Dailey"><meta name=description content="Go&rsquo;s concurrency makes it very easy to fun multiple pieces of code in parallel.
As I&rsquo;ve written about before, running many tasks at the same time (and waiting for them all to finish) is achievable using little more than the go keyword and a sync.WaitGroup.
However, a problem that you can run into is actually being too parallel.
For example, if you needed to download hundreds or thousands of files, initiating the requests for all of them at once could overwhelm the server.
Instead, it&rsquo;d be nice if we could say something like: &ldquo;download these files concurrently but only up to N at once&rdquo;."><meta name=keywords content="blog,developer,personal"><meta name=fediverse:creator content><meta name=twitter:card content="summary"><meta name=twitter:title content="A Parallel ForEach Implementation in Go"><meta name=twitter:description content="Go’s concurrency makes it very easy to fun multiple pieces of code in parallel. As I’ve written about before, running many tasks at the same time (and waiting for them all to finish) is achievable using little more than the go keyword and a sync.WaitGroup.
However, a problem that you can run into is actually being too parallel. For example, if you needed to download hundreds or thousands of files, initiating the requests for all of them at once could overwhelm the server. Instead, it’d be nice if we could say something like: “download these files concurrently but only up to N at once”."><meta property="og:url" content="https://shallowbrooksoftware.com/posts/a-parallel-foreach-implementation-in-go/"><meta property="og:site_name" content="Shallow Brook Software"><meta property="og:title" content="A Parallel ForEach Implementation in Go"><meta property="og:description" content="Go’s concurrency makes it very easy to fun multiple pieces of code in parallel. As I’ve written about before, running many tasks at the same time (and waiting for them all to finish) is achievable using little more than the go keyword and a sync.WaitGroup.
However, a problem that you can run into is actually being too parallel. For example, if you needed to download hundreds or thousands of files, initiating the requests for all of them at once could overwhelm the server. Instead, it’d be nice if we could say something like: “download these files concurrently but only up to N at once”."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-27T00:00:00+00:00"><meta property="article:modified_time" content="2025-04-27T00:00:00+00:00"><meta property="article:tag" content="Go"><link rel=canonical href=https://shallowbrooksoftware.com/posts/a-parallel-foreach-implementation-in-go/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.e927f7340e309d76dcb8fda85f1531ae7341aa9cd0b7f3ab77885dae77b1a0a2.css integrity="sha256-6Sf3NA4wnXbcuP2oXxUxrnNBqpzQt/Ord4hdrnexoKI=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://shallowbrooksoftware.com/>Shallow Brook Software
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://shallowbrooksoftware.com/posts/a-parallel-foreach-implementation-in-go/>A Parallel ForEach Implementation in Go</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2025-04-27T00:00:00Z>April 27, 2025
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
3-minute read</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/go/>Go</a></span></div></div></header><div class=post-content><p>Go&rsquo;s concurrency makes it very easy to fun multiple pieces of code in parallel.
As I&rsquo;ve <a href=/posts/limiting-concurrency-with-semaphores/>written about</a> before, running many tasks at the same time (and waiting for them all to finish) is achievable using little more than the <code>go</code> keyword and a <a href=https://pkg.go.dev/sync#WaitGroup class=external-link target=_blank rel=noopener>sync.WaitGroup</a>.</p><p>However, a problem that you can run into is actually being <em>too</em> parallel.
For example, if you needed to download hundreds or thousands of files, initiating the requests for all of them at once could overwhelm the server.
Instead, it&rsquo;d be nice if we could say something like: &ldquo;download these files concurrently but only up to N at once&rdquo;.</p><p>In my aforementioned post, I showed how this could be achieved quite simply by using a <a href=https://pkg.go.dev/golang.org/x/sync/semaphore class=external-link target=_blank rel=noopener>semaphore</a>.
One thing I failed to include, though, was a nice way to abstract this behavior in a reusable helper function that <strong>also handles errors</strong>.
Well, time to fix that!</p><h2 id=foreach>ForEach
<a class=heading-link href=#foreach><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Below is a generic implementation of this &ldquo;perform a task concurrently up to N at a time&rdquo; behavior.
The function <code>ForEach</code> accepts a list of items, a task function to process each item, and a concurrency limit (expressed as a number of goroutines).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>ForEach</span>[<span style=color:#a6e22e>T</span> <span style=color:#66d9ef>any</span>](<span style=color:#a6e22e>concurrency</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>items</span> []<span style=color:#a6e22e>T</span>, <span style=color:#a6e22e>taskFn</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>T</span>) <span style=color:#66d9ef>error</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Use an error group to limit concurrency.</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>g</span> <span style=color:#a6e22e>errgroup</span>.<span style=color:#a6e22e>Group</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>SetLimit</span>(<span style=color:#a6e22e>concurrency</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Perform tasks in parallel (up to &#34;concurrency&#34; at once).</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>item</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>items</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Ensure the proper item value is captured for Go versions older than 1.22.</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>item</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>item</span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// For each item, attempt to acquire a &#34;task slot&#34; from the error group.</span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// If the maximum number of tasks are already running, this will block.</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>Go</span>(<span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>taskFn</span>(<span style=color:#a6e22e>item</span>)
</span></span><span style=display:flex><span>		})
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Wait for all tasks to finish and return the first non-nil error (if any).</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>Wait</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Let&rsquo;s see how this helper can be used in a basic &ldquo;download some flags&rdquo; example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// List of flags to be downloaded.</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>urls</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>string</span>{
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;https://flagsapi.com/US/flat/64.png&#34;</span>,
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;https://flagsapi.com/GB/flat/64.png&#34;</span>,
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;https://flagsapi.com/AU/flat/64.png&#34;</span>,
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;https://flagsapi.com/AQ/flat/64.png&#34;</span>,
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;https://flagsapi.com/BE/flat/64.png&#34;</span>,
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Download all flags two at a time.</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ForEach</span>(<span style=color:#ae81ff>2</span>, <span style=color:#a6e22e>urls</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>url</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Fetch the data for a single flag.</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>body</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>GetURL</span>(<span style=color:#a6e22e>url</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Simulate processing the response.</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>1</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;Fetched %d bytes from %s\n&#34;</span>, len(<span style=color:#a6e22e>body</span>), <span style=color:#a6e22e>url</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// If an error occurred while fetching a flag, print it.</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;Failed to download flag: %v\n&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Pulling this behavior into a dedicated function definitely makes the calling code (which used to be a complex mixture of ideas) easier to understand.
More specifically, it de-couples the &ldquo;how do I perform the task&rdquo; logic from the &ldquo;how do I run the tasks concurrently&rdquo; machinery.</p><p>Additionally, any errors that arise (well, just the first error, techincally) will be propagated up to the caller.
Note that despite only returning a single error, the <code>ForEach</code> helper will still wait for all tasks to finish before returning (<a href=https://pkg.go.dev/golang.org/x/sync/errgroup#Group.Wait class=external-link target=_blank rel=noopener>reference</a>).
This behavior is similar to JavaScript&rsquo;s <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled class=external-link target=_blank rel=noopener>Promise.allSettled</a> utility.</p><p>Anyhow, I hope you can find this helper and example useful.
At the very least, maybe you found it informative.
Thanks for reading!</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2025
Andrew Dailey
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>