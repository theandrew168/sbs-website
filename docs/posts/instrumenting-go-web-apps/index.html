<!doctype html><html lang=en><head><title>Instrumenting Go Web Apps · Shallow Brook Software
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Andrew Dailey"><meta name=description content="Prometheus is an incredible open-source system for collecting, storing, and analyzing system metrics. In addition to the server program, numerous client libraries have been written to simplify the process of exposing metrics in your own projects. When writing Go-based web apps, I always include Go&rsquo;s client library so that information about the program can be collected, visualized, and monitored. As outlined in the official guide, it is very easy to get these basic metrics up and running:"><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Instrumenting Go Web Apps"><meta name=twitter:description content="Prometheus is an incredible open-source system for collecting, storing, and analyzing system metrics. In addition to the server program, numerous client libraries have been written to simplify the process of exposing metrics in your own projects. When writing Go-based web apps, I always include Go&rsquo;s client library so that information about the program can be collected, visualized, and monitored. As outlined in the official guide, it is very easy to get these basic metrics up and running:"><meta property="og:title" content="Instrumenting Go Web Apps"><meta property="og:description" content="Prometheus is an incredible open-source system for collecting, storing, and analyzing system metrics. In addition to the server program, numerous client libraries have been written to simplify the process of exposing metrics in your own projects. When writing Go-based web apps, I always include Go&rsquo;s client library so that information about the program can be collected, visualized, and monitored. As outlined in the official guide, it is very easy to get these basic metrics up and running:"><meta property="og:type" content="article"><meta property="og:url" content="https://shallowbrooksoftware.com/posts/instrumenting-go-web-apps/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-04-07T23:00:00+00:00"><meta property="article:modified_time" content="2024-04-07T23:00:00+00:00"><link rel=canonical href=https://shallowbrooksoftware.com/posts/instrumenting-go-web-apps/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.577e3c5ead537873430da16f0964b754a120fd87c4e2203a00686e7c75b51378.css integrity="sha256-V348Xq1TeHNDDaFvCWS3VKEg/YfE4iA6AGhufHW1E3g=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://shallowbrooksoftware.com/>Shallow Brook Software
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://shallowbrooksoftware.com/posts/instrumenting-go-web-apps/>Instrumenting Go Web Apps</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2024-04-07T23:00:00Z>April 7, 2024
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
5-minute read</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/go/>Go</a></span></div></div></header><div class=post-content><p><a href=https://prometheus.io/ class=external-link target=_blank rel=noopener>Prometheus</a> is an incredible open-source system for collecting, storing, and analyzing system metrics.
In addition to the server program, numerous <a href=https://prometheus.io/docs/instrumenting/clientlibs/ class=external-link target=_blank rel=noopener>client libraries</a> have been written to simplify the process of exposing metrics in your own projects.
When writing Go-based web apps, I always include <a href=https://github.com/prometheus/client_golang class=external-link target=_blank rel=noopener>Go&rsquo;s client library</a> so that information about the program can be collected, visualized, and monitored.
As outlined in the <a href=https://prometheus.io/docs/guides/go-application/ class=external-link target=_blank rel=noopener>official guide</a>, it is very easy to get these basic metrics up and running:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;net/http&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;github.com/prometheus/client_golang/prometheus/promhttp&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Handle</span>(<span style=color:#e6db74>&#34;/metrics&#34;</span>, <span style=color:#a6e22e>promhttp</span>.<span style=color:#a6e22e>Handler</span>())
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ListenAndServe</span>(<span style=color:#e6db74>&#34;127.0.0.1:2112&#34;</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>After running the program (<code>go run main.go</code>), you can visit its <code>/metrics</code> endpoint to view all metrics and values at the current point in time:</p><pre tabindex=0><code>curl http://localhost:2112/metrics
</code></pre><p>Here is a small sample of the data you&rsquo;ll be able to view, collect, and store.
Each line (that isn&rsquo;t a comment) represents a single <a href=https://prometheus.io/docs/concepts/data_model/ class=external-link target=_blank rel=noopener>time series</a>.
Notice how different tags (<code>code="200"</code>, <code>code="500"</code>, etc) yield independent, unique series (this will be important later):</p><pre tabindex=0><code># HELP go_goroutines Number of goroutines that currently exist.
# TYPE go_goroutines gauge
go_goroutines 6
# HELP go_memstats_alloc_bytes Number of bytes allocated and still in use.
# TYPE go_memstats_alloc_bytes gauge
go_memstats_alloc_bytes 121216
# HELP promhttp_metric_handler_requests_total Total number of scrapes by HTTP status code.
# TYPE promhttp_metric_handler_requests_total counter
promhttp_metric_handler_requests_total{code=&#34;200&#34;} 1
promhttp_metric_handler_requests_total{code=&#34;500&#34;} 0
promhttp_metric_handler_requests_total{code=&#34;503&#34;} 0
</code></pre><p>When sampled periodically and stored for weeks (or even months), you can begin to assemble a sense of how your application is behaving.
For example, you can observe garbage collection stats, memory usage, and number of active goroutines.
You can even track HTTP request traffic but it requires a bit of extra setup.</p><h1 id=http-metrics>HTTP Metrics
<a class=heading-link href=#http-metrics><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>For years, I thought that Go&rsquo;s client library included HTTP traffic stats for <em>all</em> routes.
However, this is not the case: it only includes information about the <code>/metrics</code> endpoint.
I must&rsquo;ve seen a few keywords in the data (like <code>request</code> and <code>code</code>) and jumped to the conclusion that all routes were tracked by default.</p><p>So, how do we fill in this missing info?
I want per-route information about request volume, latency, and status codes.
Instead of having to write fully-custom metrics from scratch, we can utilize another library: <a href=https://github.com/slok/go-http-metrics class=external-link target=_blank rel=noopener>go-http-metrics</a>.
It supports all major routers, is simple to configure, and includes a bunch of useful <a href=https://github.com/slok/go-http-metrics/tree/master/examples class=external-link target=_blank rel=noopener>examples</a>.
At a high level, you integrate this library by wrapping its middleware around the HTTP handlers that you want to track.</p><p>In pseudocode:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;net/http&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>metrics</span> <span style=color:#e6db74>&#34;github.com/slok/go-http-metrics/metrics/prometheus&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>metricsMiddleware</span> <span style=color:#e6db74>&#34;github.com/slok/go-http-metrics/middleware&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>metricsWrapper</span> <span style=color:#e6db74>&#34;github.com/slok/go-http-metrics/middleware/std&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// initialize the middleware with a metrics recorder
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>mmw</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>metricsMiddleware</span>.<span style=color:#a6e22e>New</span>(<span style=color:#a6e22e>metricsMiddleware</span>.<span style=color:#a6e22e>Config</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Recorder</span>: <span style=color:#a6e22e>metrics</span>.<span style=color:#a6e22e>NewRecorder</span>(<span style=color:#a6e22e>metrics</span>.<span style=color:#a6e22e>Config</span>{}),
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// wrap the HTTP handlers that you want to track
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Handle</span>(<span style=color:#e6db74>&#34;/foo&#34;</span>, <span style=color:#a6e22e>metricsWrapper</span>.<span style=color:#a6e22e>Handler</span>(<span style=color:#e6db74>&#34;/foo&#34;</span>, <span style=color:#a6e22e>mmw</span>, <span style=color:#a6e22e>fooHandler</span>))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Handle</span>(<span style=color:#e6db74>&#34;/bar&#34;</span>, <span style=color:#a6e22e>metricsWrapper</span>.<span style=color:#a6e22e>Handler</span>(<span style=color:#e6db74>&#34;/bar&#34;</span>, <span style=color:#a6e22e>mmw</span>, <span style=color:#a6e22e>barHandler</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=handler-parameters>Handler Parameters
<a class=heading-link href=#handler-parameters><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>Tracking each route requires using the <a href="https://github.com/slok/go-http-metrics/tree/master?tab=readme-ov-file#framework-compatibility-middlewares" class=external-link target=_blank rel=noopener>specific wrapper</a> that is tailored to whichever HTTP router you are using (I&rsquo;m using Go&rsquo;s standard library router).
Each wrapper exposes a <code>wrapper.Handler()</code> function that accepts three parameters:</p><ol><li>A label for the route</li><li>The initialized middleware</li><li>Your downstream HTTP handler</li></ol><p>While the latter two are fairly straightward, the first parameter is worthy of some extra explanation.
In the above example, I&rsquo;ve labeled the metrics as <code>/foo</code> and <code>/bar</code> to match their routes.
This works perfectly for routes that don&rsquo;t ever change.
That being said, what about routes that have dynamic parameters (like <code>/foo/{id}</code>)?
There are a couple ways to handle this.</p><h3 id=option-1-unique-label-per-url>Option 1: Unique Label per URL
<a class=heading-link href=#option-1-unique-label-per-url><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>First, you could supply an empty label which will cause the library to emit a new series <em>per unique URL</em>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>mux</span>.<span style=color:#a6e22e>Handle</span>(<span style=color:#e6db74>&#34;/foo/{id}&#34;</span>, <span style=color:#a6e22e>metricsWrapper</span>.<span style=color:#a6e22e>Handler</span>(<span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#a6e22e>mmw</span>, <span style=color:#a6e22e>specificFooHandler</span>))
</span></span></code></pre></div><p>This might seem convenient but is actually <strong>quite risky and could result in a cardinality explosion</strong>.
This means that every unique URL visited will result in a separate series of metrics.
The <a href=https://prometheus.io/docs/practices/instrumentation/#do-not-overuse-labels class=external-link target=_blank rel=noopener>Prometheus docs</a> warn against this pattern:</p><blockquote><p>Each labelset is an additional time series that has RAM, CPU, disk, and network costs.
Usually the overhead is negligible, but in scenarios with lots of metrics and hundreds of labelsets across hundreds of servers, this can add up quickly.
As a general guideline, try to keep the cardinality of your metrics below 10, and for metrics that exceed that, aim to limit them to a handful across your whole system.</p></blockquote><p>In my experience, providing the wrapper with an empty label and letting it generate a new series for each unique URL is rarely what I&rsquo;m after.</p><h3 id=option-2-specific-label-per-route>Option 2: Specific Label per Route
<a class=heading-link href=#option-2-specific-label-per-route><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>Instead, I prefer labeling dynamic routes with their generic match pattern:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>mux</span>.<span style=color:#a6e22e>Handle</span>(<span style=color:#e6db74>&#34;/foo/{id}&#34;</span>, <span style=color:#a6e22e>metricsWrapper</span>.<span style=color:#a6e22e>Handler</span>(<span style=color:#e6db74>&#34;/foo/{id}&#34;</span>, <span style=color:#a6e22e>mmw</span>, <span style=color:#a6e22e>specificFooHandler</span>))
</span></span></code></pre></div><p>With this approach, all requests will be aggregated under the literal label <code>/foo/{id}</code> regardless of what specific ID was provided.
To put it another way: the route will only ever emit a single series (per metric) and will group the data related to each distinct <code>foo</code> together.
See the <a href=https://github.com/slok/go-http-metrics/blob/c472df028d97fa53f3e99c760831d55908541bba/examples/custom/main.go#L51-L57 class=external-link target=_blank rel=noopener>custom example</a> for another explanation of this issue how specific labels can be used to solve it.</p><h1 id=conclusion>Conclusion
<a class=heading-link href=#conclusion><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>This post offers a brief introduction to <a href=https://prometheus.io/ class=external-link target=_blank rel=noopener>Prometheus</a> metrics and how you can easily expose them from any Go-based web application.
Despite not being tracked by default, I showed how the <a href=https://github.com/slok/go-http-metrics class=external-link target=_blank rel=noopener>go-http-metrics</a> library can be used to track HTTP request metrics for <em>all</em> routes in your application (not just the <code>/metrics</code> endpoint).
Lastly, you should be careful about how you label your per-route metrics in order to avoid excessive cardinality.
Thanks for reading!</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2024
Andrew Dailey
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>