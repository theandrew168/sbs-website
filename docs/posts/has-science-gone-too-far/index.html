<!doctype html><html lang=en><head><title>Has Science Gone Too Far? · Shallow Brook Software
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Andrew Dailey"><meta name=description content="I recently wrote an article explaining my difficulty with trying to reconcile “traditional API design” with BFFs (backend for frontend) and N+1 API calls.
It seemed tough to arrive at a &ldquo;best&rdquo; solution (and maybe one doesn&rsquo;t even really exist).
Do I build my API for general consumption (granular and resource-based) or specifically for my web frontend (coarse with multiple resources joined together)?
I settled for a middleground: use intentional frontend techniques to load secondary data after rendering the initial, primary data.
Then, if that was too cumbersome, create a BFF endpoint to power heavier pages."><meta name=keywords content="blog,developer,personal"><meta name=fediverse:creator content><meta name=twitter:card content="summary"><meta name=twitter:title content="Has Science Gone Too Far?"><meta name=twitter:description content="I recently wrote an article explaining my difficulty with trying to reconcile “traditional API design” with BFFs (backend for frontend) and N+1 API calls. It seemed tough to arrive at a “best” solution (and maybe one doesn’t even really exist). Do I build my API for general consumption (granular and resource-based) or specifically for my web frontend (coarse with multiple resources joined together)? I settled for a middleground: use intentional frontend techniques to load secondary data after rendering the initial, primary data. Then, if that was too cumbersome, create a BFF endpoint to power heavier pages."><meta property="og:url" content="https://shallowbrooksoftware.com/posts/has-science-gone-too-far/"><meta property="og:site_name" content="Shallow Brook Software"><meta property="og:title" content="Has Science Gone Too Far?"><meta property="og:description" content="I recently wrote an article explaining my difficulty with trying to reconcile “traditional API design” with BFFs (backend for frontend) and N+1 API calls. It seemed tough to arrive at a “best” solution (and maybe one doesn’t even really exist). Do I build my API for general consumption (granular and resource-based) or specifically for my web frontend (coarse with multiple resources joined together)? I settled for a middleground: use intentional frontend techniques to load secondary data after rendering the initial, primary data. Then, if that was too cumbersome, create a BFF endpoint to power heavier pages."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-08-25T00:00:00+00:00"><meta property="article:modified_time" content="2024-08-25T00:00:00+00:00"><link rel=canonical href=https://shallowbrooksoftware.com/posts/has-science-gone-too-far/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.e927f7340e309d76dcb8fda85f1531ae7341aa9cd0b7f3ab77885dae77b1a0a2.css integrity="sha256-6Sf3NA4wnXbcuP2oXxUxrnNBqpzQt/Ord4hdrnexoKI=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://shallowbrooksoftware.com/>Shallow Brook Software
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://shallowbrooksoftware.com/posts/has-science-gone-too-far/>Has Science Gone Too Far?</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2024-08-25T00:00:00Z>August 25, 2024
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
3-minute read</span></div></div></header><div class=post-content><p>I recently <a href=/posts/brain-dump-bffs-and-api-calls/>wrote an article</a> explaining my difficulty with trying to reconcile “traditional API design” with BFFs (backend for frontend) and N+1 API calls.
It seemed tough to arrive at a &ldquo;best&rdquo; solution (and maybe one doesn&rsquo;t even really exist).
Do I build my API for general consumption (granular and resource-based) or specifically for my web frontend (coarse with multiple resources joined together)?
I settled for a middleground: use intentional frontend techniques to load secondary data <em>after</em> rendering the initial, primary data.
Then, if that was too cumbersome, create a BFF endpoint to power heavier pages.</p><p>Even after documenting everything I knew about the designs and their tradeoffs, I didn&rsquo;t feel like the problem was truly resolved.
What if I create a mobile app that requires <em>different</em> BFF endpoints?
Do I just make them as needed?
I really wished that I could just create a &ldquo;write one, use everywhere&rdquo; REST API.
At one point I wondered: is <a href=https://graphql.org/ class=external-link target=_blank rel=noopener>GraphQL</a> the answer?
After the upfront cost of specifying the data model and implemeting resolvers, clients would be able to request whatever data they need: granular OR coarse.
Sounds perfect, right?</p><p>But then, I took a beat.
I paused and remembered an old proverb:</p><blockquote><p>You can rarely make a system simpler by adding a bunch of stuff.</p></blockquote><p>Was this was all getting to be too much?
Had science gone too far?
Bloggulus doesn’t need to be an SPA: I just wanted to explore that architecture and see how it felt to develope the frontend and backend separately.
While fun and quite informative, I’m starting to feel like the stack is overkill for this project (and probably many others, to be honest).
Perhaps it&rsquo;s time to get off of this wild ride through SPA-town.
To that end, I’m considering going to back to server-side rendering for the primary web UI.</p><p>I’d probably keep the “traditional API” around but might drop the BFF endpoints I’ve created already (such as <code>GET /api/v1/articles</code>).
What about making a browser extension?
That’d mainly be for modifying app state (following a blog / adding a page) so the traditional API should cover that.
What about a mobile app?
I’m not sure.
Maybe I just skip it since the site is already mobile-friendly from a CSS point of view.
Or perhaps there is a quick way to bundle up an SPA as a web-view and still publish it as a standalone app.
It seems like there has been <a href=https://developers.google.com/codelabs/pwa-in-play class=external-link target=_blank rel=noopener>some work</a> done on this concept.</p><p>If I decide to make any major changes, I&rsquo;ll be sure to post an update.
Thanks for reading!</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2025
Andrew Dailey
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script data-goatcounter=https://shallowbrooksoftware.goatcounter.com/count async src=//gc.zgo.at/count.js></script></body></html>