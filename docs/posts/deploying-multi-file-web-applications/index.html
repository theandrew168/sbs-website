<!doctype html><html lang=en><head><title>Deploying Multi-File Web Applications · Shallow Brook Software
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Andrew Dailey"><meta name=description content="For quite a long time, I&rsquo;ve had a question: what is the best way to deploy multi-file web applications?
When I say &ldquo;multi-file&rdquo;, I mean any application that doesn&rsquo;t easily build into a single binary.
In general, web apps have many files to worry about: HTML templates, static assets, migrations, etc.
For ecosystems where the build output contains multiple directories and files, how we can safely deploy a new version of the app without any disruptions?"><meta name=keywords content="blog,developer,personal"><meta name=fediverse:creator content><meta name=twitter:card content="summary"><meta name=twitter:title content="Deploying Multi-File Web Applications"><meta name=twitter:description content="For quite a long time, I’ve had a question: what is the best way to deploy multi-file web applications? When I say “multi-file”, I mean any application that doesn’t easily build into a single binary. In general, web apps have many files to worry about: HTML templates, static assets, migrations, etc. For ecosystems where the build output contains multiple directories and files, how we can safely deploy a new version of the app without any disruptions?"><meta property="og:url" content="https://shallowbrooksoftware.com/posts/deploying-multi-file-web-applications/"><meta property="og:site_name" content="Shallow Brook Software"><meta property="og:title" content="Deploying Multi-File Web Applications"><meta property="og:description" content="For quite a long time, I’ve had a question: what is the best way to deploy multi-file web applications? When I say “multi-file”, I mean any application that doesn’t easily build into a single binary. In general, web apps have many files to worry about: HTML templates, static assets, migrations, etc. For ecosystems where the build output contains multiple directories and files, how we can safely deploy a new version of the app without any disruptions?"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-10T00:00:00+00:00"><meta property="article:modified_time" content="2025-05-10T00:00:00+00:00"><meta property="article:tag" content="Hosting"><link rel=canonical href=https://shallowbrooksoftware.com/posts/deploying-multi-file-web-applications/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.e927f7340e309d76dcb8fda85f1531ae7341aa9cd0b7f3ab77885dae77b1a0a2.css integrity="sha256-6Sf3NA4wnXbcuP2oXxUxrnNBqpzQt/Ord4hdrnexoKI=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://shallowbrooksoftware.com/>Shallow Brook Software
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://shallowbrooksoftware.com/posts/deploying-multi-file-web-applications/>Deploying Multi-File Web Applications</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2025-05-10T00:00:00Z>May 10, 2025
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
6-minute read</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/hosting/>Hosting</a></span></div></div></header><div class=post-content><p>For quite a long time, I&rsquo;ve had a question: what is the best way to deploy multi-file web applications?
When I say &ldquo;multi-file&rdquo;, I mean any application that doesn&rsquo;t easily build into a single binary.
In general, web apps have many files to worry about: HTML templates, static assets, migrations, etc.
For ecosystems where the build output contains multiple directories and files, how we can safely deploy a new version of the app without any disruptions?</p><p>The solution is actually quite simple: keep each version of the app in separate directories and mark one as &ldquo;active&rdquo; with a <a href=https://en.wikipedia.org/wiki/Symbolic_link class=external-link target=_blank rel=noopener>symlink</a>!
Let&rsquo;s dig into the details, talk about some background context, and see how this works in practice.</p><h2 id=background>Background
<a class=heading-link href=#background><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>In <a href=https://go.dev class=external-link target=_blank rel=noopener>Go</a>, you can use the <a href=https://pkg.go.dev/embed class=external-link target=_blank rel=noopener>embed</a> package to bundle your code and all other app resources into single file.
Then, deployment becomes trivial: overwrite the old binary with the new one and restart the service.
This works (and is safe) because the binary itself gets loaded into memory when the process starts.
Therefore, when the file gets replaced by the new version, the current app process is unaffected.
Only when the service restarts will the new file be loaded and executed.</p><p>As it turns out, most other ecosystems are <em>not</em> like Go and lack this functionality.
I&rsquo;m talking about languages like Python (Flask, Django, etc) or Node.js (Next.js, Remix, SvelteKit, etc).
For these apps where multiple files <em>are</em> required to be deployed, it isn&rsquo;t completely safe to just drop the new directory structure over top of the old one and restart.
While you <em>can</em> do that and it&rsquo;ll technically work, there is a potential race condition issue.</p><p>Requests that reference old resources could break in the short gap between replacing the underlying app files and restarting the service.
For example, consider a request for the old version of the app that is bound for <code>/img/foo.png</code>.
If the new version removes it, the request could arrive <em>between</em> deploying the new files and restarting the service which would result in an unexpected error (because the image can no longer be found).
How can this be solved?</p><h2 id=deployment>Deployment
<a class=heading-link href=#deployment><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>For these multi-file applications, what actually needs to happen during a deployment?
I&rsquo;m going to use the example of a Node.js app managed via systemd on an Ubuntu 24.04 server.
First things first: the server will need to have the app&rsquo;s runtime installed.
This is a one-time operation that can be performed when initializing the server: <code>apt install nodejs</code>.</p><p>Next, we need to get the source code to the server somehow.
We could either &ldquo;push&rdquo; the code to the server by copying and unzipping an archive or &ldquo;pull&rdquo; the code by cloning or downloading it directly.
Each method has tradeoffs and should be handled on a case-by-case basis.
In my experience, though, &ldquo;pulling&rdquo; (via <code>git clone</code> and <code>git checkout &lt;hash></code>) is pretty convenient, especially when dealing with open-source application that don&rsquo;t require any authentication to access the source code.</p><p>Then, for any given version of the app, we need to do some additional prep work before it will be ready to run: installing dependencies and building the code.
Installing dependencies is easy enough: <code>npm install</code>.
Building is usually quite simple as well (depending on the framework): <code>npm run build</code>.</p><p>The last question then becomes: how do we run this?
What command do we put in the <code>ExecStart</code> field of our <a href="https://www.freedesktop.org/software/systemd/man/latest/systemd.service.html#ExecStart=" class=external-link target=_blank rel=noopener>systemd service</a> file?
Well, it depends on the framework.
For something like Next.js, we&rsquo;d run <code>npm run start</code>.
For a library that outputs a Node.js-ready &ldquo;build&rdquo; directory (like SvelteKit), the command would be <code>node build/</code>.</p><p>With all that out of the way, we can now restart the app: <code>systemctl restart &lt;myapp></code>.
And there we have it: a new version of the app has been deployed!</p><h2 id=idea>Idea
<a class=heading-link href=#idea><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Naively, this approach has issues.
As mentioned before, performing the deployment steps <strong>in the same directory as the currently-running app</strong> can lead to race conditions and ultimately user-facing errors.
Once the app is running, how can a new version of the code be deployed, built, and started <strong>without impacting the app&rsquo;s availability</strong>?</p><p>In other non-single-binary ecosystems such as Python, tools like <a href=https://shiv.readthedocs.io/en/latest/ class=external-link target=_blank rel=noopener>shiv</a> solve this problem by zipping your project into a single archive and then transparently unzipping it into a unique directory prior to execution.
This way, the individual files of different versions don&rsquo;t conflict with each other and cutover race conditions are avoided.</p><p>Can we do something similar to this but in a more ubiquitous way?
Unfortunately, systemd doesn&rsquo;t have a native way to say &ldquo;use this parameterized working directory&rdquo; at startup.
Instead, one possible solution to this that I really like is simply making the <code>WorkingDirectory</code> a symlink (<a href=https://unix.stackexchange.com/questions/242019/set-workingdirectory-using-a-variable/629958#629958 class=external-link target=_blank rel=noopener>reference</a>).
Then, that symlink can point to any given version of the project available on the server.</p><h2 id=solution>Solution
<a class=heading-link href=#solution><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>How would deployments work using this approach?
We&rsquo;d first have a separate directory for each version of the app that has been deployed (<code>/usr/local/src/&lt;myapp>/&lt;hash></code> for example).
There would then exist a symlink (something like <code>/usr/local/src/&lt;myapp>/active</code>) that points to whichever version of the app is currently active.
Lastly, in the systemd service file, we would set <code>WorkingDirectory</code> to our &ldquo;active&rdquo; symlink.</p><p>When deploying a new version, the steps are as follows:</p><ol><li>Clone and checkout the code into a new directory that correponds to the version&rsquo;s commit hash.<ol><li>You could also use a tag or something else here, if you prefer.</li></ol></li><li>From this new version directory, run the install and build steps.</li><li>Update the &ldquo;active&rdquo; symlink to point to the new version directly: <code>ln -sfn &lt;hash> current</code>.</li><li>Restart the systemd service to start using the code and resources from the new version.</li></ol><p>And&mldr; that&rsquo;s it!
That&rsquo;s the whole approach: build each version of the app in a separate directory and use a symlink to control which version is &ldquo;active&rdquo;.
Also, because systemd checks <code>WorkingDirectory</code> at startup, the old files will still be used even after the symlink is swapped.
The new files won’t be picked up until the service restarts which avoids the race condition from earlier.</p><h2 id=conlusion>Conlusion
<a class=heading-link href=#conlusion><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>In this post, we went over an approach for safely deploying multi-file web applications.
Since most web app frameworks and ecosystems <em>don&rsquo;t</em> support bundling everything into a single, convenient binary, we have to get a bit creative.
Thankfully, with a bit of clever symlinking, we can ensure that new versions are deployed without impacting the service&rsquo;s availability.
Just be sure to clean up the old version directories from time to time and you&rsquo;ll be off to the races!</p><p>Thanks for reading!</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2025
Andrew Dailey
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script data-goatcounter=https://shallowbrooksoftware.goatcounter.com/count async src=//gc.zgo.at/count.js></script></body></html>