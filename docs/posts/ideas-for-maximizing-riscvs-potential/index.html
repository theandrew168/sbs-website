<!doctype html><html lang=en><head><title>Ideas for Maximizing RISC-V's Potential · Shallow Brook Software
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Andrew Dailey"><meta name=description content="There has been a lot of buzz surrounding the slowness, instability, and complexity of modern software systems. It seems as though more and more people are feeling and observing bloat and bugginess in their day-to-day usage of computers. In many situations, the mediocrity of today&rsquo;s technology has become so common that it isn&rsquo;t even seen as an issue.
During my few years spent in industry, these sort of quotes were heard almost daily:"><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Ideas for Maximizing RISC-V's Potential"><meta name=twitter:description content="There has been a lot of buzz surrounding the slowness, instability, and complexity of modern software systems. It seems as though more and more people are feeling and observing bloat and bugginess in their day-to-day usage of computers. In many situations, the mediocrity of today&rsquo;s technology has become so common that it isn&rsquo;t even seen as an issue.
During my few years spent in industry, these sort of quotes were heard almost daily:"><meta property="og:title" content="Ideas for Maximizing RISC-V's Potential"><meta property="og:description" content="There has been a lot of buzz surrounding the slowness, instability, and complexity of modern software systems. It seems as though more and more people are feeling and observing bloat and bugginess in their day-to-day usage of computers. In many situations, the mediocrity of today&rsquo;s technology has become so common that it isn&rsquo;t even seen as an issue.
During my few years spent in industry, these sort of quotes were heard almost daily:"><meta property="og:type" content="article"><meta property="og:url" content="https://shallowbrooksoftware.com/posts/ideas-for-maximizing-riscvs-potential/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-11-11T00:00:00+00:00"><meta property="article:modified_time" content="2020-11-11T00:00:00+00:00"><link rel=canonical href=https://shallowbrooksoftware.com/posts/ideas-for-maximizing-riscvs-potential/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.577e3c5ead537873430da16f0964b754a120fd87c4e2203a00686e7c75b51378.css integrity="sha256-V348Xq1TeHNDDaFvCWS3VKEg/YfE4iA6AGhufHW1E3g=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://shallowbrooksoftware.com/>Shallow Brook Software
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://shallowbrooksoftware.com/posts/ideas-for-maximizing-riscvs-potential/>Ideas for Maximizing RISC-V's Potential</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2020-11-11T00:00:00Z>November 11, 2020
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
9-minute read</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/risc-v/>Risc-V</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/assembly/>Assembly</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/forth/>Forth</a></span></div></div></header><div class=post-content><p>There has been a lot of buzz surrounding the slowness, instability, and complexity of modern software systems.
It seems as though more and more people are feeling and observing bloat and bugginess in their day-to-day usage of computers.
In many situations, the mediocrity of today&rsquo;s technology has become so common that it isn&rsquo;t even seen as an issue.</p><p>During my few years spent in industry, these sort of quotes were heard almost daily:</p><ul><li><em>Looks like Windows crashed. What a surprise!</em></li><li><em>Shoot, my PC decided to do updates&mldr; see you in an hour.</em></li><li><em>This meeting room isn&rsquo;t working. Let&rsquo;s try to schedule a different one.</em></li><li><em>Just keeping refreshing the page until it renders correctly.</em></li></ul><p>Businesses and individuals lose countless hours to these types of problems every day but they are usually brushed off with a laugh.
The stability of Windows is the source of many jokes.
Backup plans are necessary for inconsistent meeting room reservations.
Are these situations an inevitability of computer interactions or has something gone wrong?</p><h1 id=existing-opinions>Existing Opinions
<a class=heading-link href=#existing-opinions><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>In his blog post <a href=https://tonsky.me/blog/disenchantment/ class=external-link target=_blank rel=noopener>Software Disenchantment</a>, Nikita Prokopov (tonsky) presents evidence for &ldquo;industry&rsquo;s lack of care for efficiency, simplicity, and excellence&rdquo;.
In his presentation <a href=https://caseymuratori.com/blog_0031 class=external-link target=_blank rel=noopener>The 30 Million Line Problem</a>, Casey Muratori argues that the interaction between software and hardware has the potential to be simplified.
In his article <a href=https://idlewords.com/talks/website_obesity.htm class=external-link target=_blank rel=noopener>The Website Obesity Crisis</a>, Maciej Ceglowski describes how websites have gotten progressively larger and slower.
In his talk <a href="https://www.youtube.com/watch?v=pW-SOdj4Kkk" class=external-link target=_blank rel=noopener>Preventing the Collapse of Civilization</a>, Jonathan Blow compares modern software development to historical technological advancements.
Lastly, in his 1995 essay <a href=https://cr.yp.to/bib/1995/wirth.pdf class=external-link target=_blank rel=noopener>A Plea for Lean Software</a>, Niklaus Wirth describes causes for what he calls &ldquo;fat software&rdquo;.
1995!
This problem has a history.</p><h1 id=my-opinion>My Opinion
<a class=heading-link href=#my-opinion><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>I agree with the sentiments expressed in each of these posts.
In some sense, it leaves me with a feeling of helplessness: what can we do about this?
Is the ship of modern software development too large to turn?
What is the real problem?
Even if we knew the answer to that, how could we fix our technological trajectory?
I don&rsquo;t want to accept that the tools we use everyday are incapable of being fast and reliable.</p><p>I&rsquo;ve spent a lot of time thinking about this problem.
Not only what the root cause may be, but also what can be done to mitigate it.
The videos and articles mentioned prior have all helped guide me toward the following ideas.
In short:</p><ol><li>Operating systems provide great value, but often at a cost</li><li>Modern software exhibits an abundance of code and complexity</li><li>Usefulness can present itself in different, non-traditional ways</li><li>There are other routes to actualizing useful behavior from computers</li><li>The Bronzebeard project is my attempt to enable one alternate route</li></ol><h1 id=idea-1-where-things-went-wrong>Idea 1: Where Things Went Wrong
<a class=heading-link href=#idea-1-where-things-went-wrong><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>Are modern operating systems the epitome of software efficiency?
By this, I mean to ask if they bring enough value to the table to justify their costs.
But Linux is free!
True, but I&rsquo;m not referring to monetary costs: I&rsquo;m referring to complexity and the sheer volume of code between you and chunk of silicon at the heart of your machine.</p><p>To be fair, I&rsquo;m not really in a good position to answer this question.
I have zero kernel development experience at all.
However, there do exist veteran programmers who take issue with the state of modern kernel development.
<a href=https://rene.rebe.de/ class=external-link target=_blank rel=noopener>René Rebe</a> supports an ongoing conversation about this exact topic.
Through his <a href=https://www.youtube.com/user/renerebe class=external-link target=_blank rel=noopener>YouTube channel</a>, René presents frequent ideas and criticisms relating to operating system design and implementation.
He explains how better languages and better designs (such as <a href=https://en.wikipedia.org/wiki/Microkernel class=external-link target=_blank rel=noopener>microkernel</a>) could be an important step in future OS innovation.</p><h1 id=idea-2-too-much-code-too-much-complexity>Idea 2: Too Much Code, Too Much Complexity
<a class=heading-link href=#idea-2-too-much-code-too-much-complexity><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>Most of the time, code quantity is really a poor measure of anything.
Talking about a project&rsquo;s &ldquo;lines of code&rdquo; doesn&rsquo;t usually amount to much.
However, as a project&rsquo;s size increases, so does it&rsquo;s learning curve.
In my opinion, the easiest code to understand and maintain is code that doesn&rsquo;t exist.
A large amount of recent language debate has pertained to matters of safety.
Many agree that C is an &ldquo;unsafe&rdquo; language while Go and Rust are &ldquo;safer&rdquo; alternatives.
While I do concur that safety is important, I think that <em>quantity</em> may be more significant.</p><p>I think at some scale, the safety of a language loses impact.
Thirty million line of code in <em>any</em> language is going to result in subtle, nuanced, cross-cutting bugs.
As soon as a project grows to the point where no single developer can understand the whole picture, I think it&rsquo;s game over.
At such a scale, achieving optimal performance and reliability becomes nearly impossible because human intercommunication is lossy and inefficient.
I think that innovation will come not from writing <em>safer</em> code, but from writing <em>less</em> code.</p><h1 id=idea-3-what-makes-something-useful>Idea 3: What Makes Something Useful?
<a class=heading-link href=#idea-3-what-makes-something-useful><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>Is a fully-featured, multi-user OS necessary for a computer to be useful?
Do specific, targeted applications such as a webserver need that?
I propose that, in fact, something like a webserver is made <em>less</em> secure due to the multi-user model and features running behind it.
Perhaps even the performance of a dedicated server could be better without that extra overhead.</p><p>When it comes to &ldquo;value&rdquo;, there are two equally-important angles to consider.
The first and most common is the value that comes from features: more code added in order to do more things.
The second and less common angle is the value added <em>implicity</em> by exposing the same features with less resources.
If a program can do the same thing with half the code, that&rsquo;s value added.
If it can do the same task in half the time, that&rsquo;s also value added.
If you could accomplish 90% of the existing features with only 10% of the code, that may be a big win!</p><h1 id=idea-4-other-paths-to-success>Idea 4: Other Paths to Success
<a class=heading-link href=#idea-4-other-paths-to-success><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>What about writing your program or application directly in <a href=https://en.wikipedia.org/wiki/Assembly_language class=external-link target=_blank rel=noopener>assembly</a>?
Oof, that&rsquo;d hurt portability&mldr; right?
I&rsquo;d say &ldquo;yes&rdquo; if the goal was to support multiple architectures.
However, I&rsquo;d say &ldquo;no&rdquo; if a calculated choice was made to target a <em>specific</em> architecture.
Given the title of the post, you probably know where I&rsquo;m going this: <a href=https://en.wikipedia.org/wiki/RISC-V class=external-link target=_blank rel=noopener>RISC-V</a>.
RISC-V is an open standard instruction set architecture released under open source licences.
What if you were to simply invest in the RISC-V ISA and embrace its assembly dialect as the foundation for modern programs?
Think about how much compiler and operating system cruft you could leave behind!</p><p>If you were to hit the reset button and completely start over, what would it take to achieve usefulness?
How many instructions?
How many lines of assembly?
Do we need C or Rust?
Assembly may not be the most productive language but there are simple, high-level alternatives.
I think that <a href=https://en.wikipedia.org/wiki/Forth_%28programming_language%29 class=external-link target=_blank rel=noopener>Forth</a> is definitely a contender and worth taking a look at.
A minimal Forth implementation can be built in a few hundred instructions and then a useful, interactive system can built in a few hundred Forth words.
That sounds pretty efficient!
Perhaps it would even be fairly secure.</p><p><strong>&ldquo;There are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies, and the other way is to make it so complicated that there are no obvious deficiencies. The first method is far more difficult.&rdquo;</strong> - C. A. R. Hoare</p><h1 id=idea-5-the-bronzebeard-project>Idea 5: The Bronzebeard Project
<a class=heading-link href=#idea-5-the-bronzebeard-project><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p><a href=https://github.com/theandrew168/bronzebeard class=external-link target=_blank rel=noopener>Bronzebeard</a> is a minimal ecosystem for bare-metal RISC-V development.
I&rsquo;ve written a basic, standalone <a href=https://github.com/theandrew168/bronzebeard/blob/master/bronzebeard/asm.py class=external-link target=_blank rel=noopener>assembler</a> with no dependency on existing toolchains.
I also wrote a useful subset of <a href=https://en.wikipedia.org/wiki/USB#Device_Firmware_Upgrade class=external-link target=_blank rel=noopener>DFU</a> in order to support running programs on a few existing RISC-V boards.
Can I make small-scale devices such as the <a href=https://www.seeedstudio.com/Sipeed-Longan-Nano-RISC-V-GD32VF103CBT6-Development-Board-p-4205.html class=external-link target=_blank rel=noopener>Longan Nano</a>, <a href=https://www.seeedstudio.com/Wio-Lite-RISC-V-GD32VF103-p-4293.html class=external-link target=_blank rel=noopener>Wio Lite</a>, and <a href=https://www.sifive.com/boards/hifive1-rev-b class=external-link target=_blank rel=noopener>HiFive1 Rev B</a> useful without all of the default frameworks and SDKs?
If not using those, then what does the toolset look like?
Assembly is really the lowest level you can effectively go so that&rsquo;s where I&rsquo;ve started.</p><p>In Abelson and Sussman&rsquo;s <a href=https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-10.html#%25_sec_1.1 class=external-link target=_blank rel=noopener>Structure and Interpretation of Computer Programs</a>, they describe the core elements of programming:</p><ul><li><strong>primitive expressions</strong> - which represent the simplest entities the language is concerned with</li><li><strong>means of combination</strong> - by which compound elements are built from simpler ones</li><li><strong>means of abstraction</strong> - by which compound elements can be named and manipulated as units</li></ul><p>How simply and effectively can these elements be achieved when starting from scratch?
Forth is the most minimal approach I&rsquo;ve seen.
Furthermore, I think that Forth&rsquo;s design is rooted so literally upon these three elements that it almost <em>encourages</em> productive abstrations.
It limits you to the &ldquo;good&rdquo; kind of abstraction: combining smaller units of low-level functionality into larger and larger high-level procedures.
I consider a &ldquo;bad&rdquo; abstraction to be when extra code is added in preemptive concern for future changes that rarely occur.</p><h1 id=conclusion>Conclusion
<a class=heading-link href=#conclusion><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>In short, there is simply too much code and complexity underlying most modern systems.
The rise of RISC-V will enable programmers to embrace and control hardware at its lowest and most powerful level.
Programming languages such as C are valuable for their ability to paint over the machine that they target.
Perhaps that isn&rsquo;t always a good thing.
I think that there is sometimes value in doing just the opposite: making a conscious and well-intended choice to utilize a single platform to its fullest.</p><p>All of these ideas are heavily opinionated without a lot of science or evidence.
They are simply my opinion based on what I&rsquo;ve experienced and the research I&rsquo;ve done.
Modern operating systems and general computing are definitely a marvel but they are far from perfect.
There are many signs that point to things actually being quite poor.
If people ignore this problem then nothing will ever change.
If people just think the same way they always have then nothing will ever change.
If people assume that what we have now is &ldquo;good enough&rdquo; then nothing will ever change.</p><p>I want to enable and encourage other developers to explore bare-metal development.
I want to build an ecosystem that accessible to everyone with a computer, regardless of their operating system or prior programming experience.
By investing in the RISC-V ISA and its ecosystem, we no longer need an abstration over the assembly language by which it speaks.
RISC-V assembly can be a new foundation for future servers, programs, and operating systems.</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2024
Andrew Dailey
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>