<!doctype html><html lang=en><head><title>Behavioral Abstractions in TypeScript · Shallow Brook Software
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Andrew Dailey"><meta name=description content="Almost every application needs to communicate with the outside world in one form or another.
It could be by scraping a web page, hitting a REST API, or simply talking to a database.
If an application depends on the specific details of any of these communications, however, then it becomes much more difficult to test.
Instead, a program&rsquo;s domain logic should depend on abstract behaviors instead of concrete implementations.
I think that this is one of the most important facets of system design."><meta name=keywords content="blog,developer,personal"><meta name=fediverse:creator content><meta name=twitter:card content="summary"><meta name=twitter:title content="Behavioral Abstractions in TypeScript"><meta name=twitter:description content="Almost every application needs to communicate with the outside world in one form or another. It could be by scraping a web page, hitting a REST API, or simply talking to a database. If an application depends on the specific details of any of these communications, however, then it becomes much more difficult to test. Instead, a program’s domain logic should depend on abstract behaviors instead of concrete implementations. I think that this is one of the most important facets of system design."><meta property="og:url" content="https://shallowbrooksoftware.com/posts/behavioral-abstractions-in-typescript/"><meta property="og:site_name" content="Shallow Brook Software"><meta property="og:title" content="Behavioral Abstractions in TypeScript"><meta property="og:description" content="Almost every application needs to communicate with the outside world in one form or another. It could be by scraping a web page, hitting a REST API, or simply talking to a database. If an application depends on the specific details of any of these communications, however, then it becomes much more difficult to test. Instead, a program’s domain logic should depend on abstract behaviors instead of concrete implementations. I think that this is one of the most important facets of system design."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-03T00:00:00+00:00"><meta property="article:modified_time" content="2024-03-03T00:00:00+00:00"><meta property="article:tag" content="TypeScript"><link rel=canonical href=https://shallowbrooksoftware.com/posts/behavioral-abstractions-in-typescript/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.e927f7340e309d76dcb8fda85f1531ae7341aa9cd0b7f3ab77885dae77b1a0a2.css integrity="sha256-6Sf3NA4wnXbcuP2oXxUxrnNBqpzQt/Ord4hdrnexoKI=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://shallowbrooksoftware.com/>Shallow Brook Software
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://shallowbrooksoftware.com/posts/behavioral-abstractions-in-typescript/>Behavioral Abstractions in TypeScript</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2024-03-03T00:00:00Z>March 3, 2024
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
5-minute read</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/typescript/>TypeScript</a></span></div></div></header><div class=post-content><p>Almost every application needs to communicate with the outside world in one form or another.
It could be by scraping a web page, hitting a REST API, or simply talking to a database.
If an application depends on the specific details of any of these communications, however, then it becomes much more difficult to test.
Instead, a program&rsquo;s domain logic should depend on <em>abstract behaviors</em> instead of concrete implementations.
I think that this is one of the most important facets of system design.</p><h1 id=fetching-web-pages>Fetching Web Pages
<a class=heading-link href=#fetching-web-pages><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>I&rsquo;ve recently been implementing my <a href=https://bloggulus.com/ class=external-link target=_blank rel=noopener>Bloggulus</a> web application in <a href=https://github.com/theandrew168/bloggulus-svelte/tree/main class=external-link target=_blank rel=noopener>Svelte + TypeScript</a> for fun and experience.
One step of the syncing process involves manually retrieving a post&rsquo;s content if it isn&rsquo;t present in the RSS / Atom feed.
My initial approach to this was to simply use <a href=https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch class=external-link target=_blank rel=noopener>fetch</a> inline:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>syncPost</span>(<span style=color:#a6e22e>post</span>: <span style=color:#66d9ef>Post</span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>void</span>&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>content</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>post</span>.<span style=color:#a6e22e>content</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>content</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>resp</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#a6e22e>post</span>.<span style=color:#a6e22e>url</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>content</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>resp</span>.<span style=color:#a6e22e>text</span>();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>// insert new post, etc
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>This works, so what is the problem?
Well, the problem arises when it comes to testing this process.
If I want to verify that posts with missing content are handled correctly, I have to give the post a legitimate URL.
Otherwise, the code will attempt to fetch an invalid page and throw an error.
Sure, I <em>could</em> test against a real web page (like <a href=https://example.com/ class=external-link target=_blank rel=noopener>example.com</a> or one of my own sites) but do I really want to write tests that depend on:</p><ol><li>Having an active internet connection</li><li>The internet connection being stable and consistent</li><li>The permanent existence of a specific web page</li></ol><p>That sounds like a pain.
Perhaps I could spin up a small web server as part of the testing to serve mock pages on a local port?
Again, I <em>could</em> do that, but surely there must be a better way.</p><h1 id=basic-behavior>Basic Behavior
<a class=heading-link href=#basic-behavior><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>What does my application actually depend on?
What does it need here?
It doesn&rsquo;t really need to know about the <a href=https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API class=external-link target=_blank rel=noopener>Fetch API</a> at all.
In more abstract terms, the application just needs a bit of behavior that says: here is a URL, give me some content.
It needs a function that fetches pages:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>PageFetcher</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>fetchPage</span><span style=color:#f92672>:</span> (<span style=color:#a6e22e>url</span>: <span style=color:#66d9ef>string</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>string</span>&gt;;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>With this basic behavioral abstraction, we can make a small (but important) refactor to our code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>syncPost</span>(<span style=color:#a6e22e>post</span>: <span style=color:#66d9ef>Post</span>, <span style=color:#a6e22e>pageFetcher</span>: <span style=color:#66d9ef>PageFetcher</span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>void</span>&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>content</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>post</span>.<span style=color:#a6e22e>content</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>content</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>content</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>pageFetcher</span>.<span style=color:#a6e22e>fetchPage</span>(<span style=color:#a6e22e>post</span>.<span style=color:#a6e22e>url</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>// insert new posts, etc
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>With this small change, our code no longer depends on the implementation details of fetching pages: it only depends on the behavior in abstract.
The value added by this change becomes clear when we revisit the problem of writing tests for the sync process.
Instead of having to jump through some the painful aforementioned hoops, we can just write a mock implementation that simulates a legitimate page retrieval:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MockPageFetcher</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>page</span>: <span style=color:#66d9ef>string</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>constructor</span>(<span style=color:#a6e22e>page</span>: <span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>page</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>page</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>// this method implements the PageFetcher interface
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>async</span> <span style=color:#a6e22e>fetchPage</span>(<span style=color:#a6e22e>url</span>: <span style=color:#66d9ef>string</span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>string</span>&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>page</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>test</span>(<span style=color:#e6db74>&#34;syncPost&#34;</span>, <span style=color:#66d9ef>async</span> () <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// construct a PageFetcher that always returns &#34;Hello, World!&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>mockPageFetcher</span>: <span style=color:#66d9ef>PageFetcher</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>MockPageFetcher</span>(<span style=color:#e6db74>&#34;Hello, World!&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// attempt to sync a post using our mock fetcher
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>post</span>: <span style=color:#66d9ef>Post</span> <span style=color:#f92672>=</span> { <span style=color:#a6e22e>url</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;https://example.com/hello&#34;</span> };
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>syncPost</span>(<span style=color:#a6e22e>post</span>, <span style=color:#a6e22e>mockPageFetcher</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// the sync process should have fetched our &#34;Hello, World!&#34; page
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>expect</span>(<span style=color:#a6e22e>post</span>.<span style=color:#a6e22e>body</span>).<span style=color:#a6e22e>to</span>.<span style=color:#a6e22e>equal</span>(<span style=color:#e6db74>&#34;Hello, World!&#34;</span>);
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>I don&rsquo;t know about you, but I think that this is very powerful!
Because our domain logic doesn&rsquo;t care about <em>how</em> we fetch pages, we can pass it a special, hand-crafted implementation of the interface and it won&rsquo;t know the difference.
It only knows that it needs to fetch a page and has been provided with the tools to make it happen.</p><h1 id=complex-behaviors>Complex Behaviors
<a class=heading-link href=#complex-behaviors><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>This idea can be extended to encompass sets of behaviors, as well.
Consider how this can be applied to decoupling your application code from a database.
You code doesn&rsquo;t <em>need</em> to know about database connections and SQL queries.
It only needs to know how to perform basic storage operations on domain types (create, read, update, and delete).</p><p>Bloggulus has the concept of a tag.
Tags are strings that represent topics found within a post&rsquo;s content.
From an application point of view, tags can be created, read (individually or in bulk), and deleted.
Since we know what the behaviors are, let&rsquo;s put them into an interface!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>TagStorage</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>create</span><span style=color:#f92672>:</span> (<span style=color:#a6e22e>params</span>: <span style=color:#66d9ef>CreateTagParams</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>Tag</span>&gt;;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>list</span><span style=color:#f92672>:</span> () <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>Tag</span><span style=color:#960050;background-color:#1e0010>[]</span>&gt;;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>readById</span><span style=color:#f92672>:</span> (<span style=color:#a6e22e>id</span>: <span style=color:#66d9ef>string</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>Tag</span> <span style=color:#960050;background-color:#1e0010>|</span> <span style=color:#a6e22e>undefined</span>&gt;;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>delete</span><span style=color:#f92672>:</span> (<span style=color:#a6e22e>tag</span>: <span style=color:#66d9ef>Tag</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>void</span>&gt;;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Just like before, the rest of the application depends only on this interface and not any specific implementation.
Any class or object that has the matching method signatures can be used in places where <code>TagStorage</code> is required.
The &ldquo;real&rdquo; implementation can be a class that hides the database connection and uses SQL to talk to a PostgreSQL database.
A &ldquo;fake&rdquo; implementation (for testing) can be one that stores tags in memory (likely in a <code>Record&lt;string, Tag></code>) and manipulates them with standard object operations.</p><h1 id=conclusion>Conclusion
<a class=heading-link href=#conclusion><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>I think that it is always a good idea to separate behavior and implementation when it comes to how your app interacts with the world around it.
By representing behavior as an interface, you gain the freedom to implement the described functionality in different ways.
Despite only likely having one true implementation at runtime, the opportunities to provide finely-controlled mock implementations during testing adds a large amount of value.
It allows you to more easily test the most important (and often undertested) areas of your code: those that interact with external systems.</p><p>The concept of an interface is ubiquitous across software engineering and I use this pattern everywhere.
Even across different projects and programming languages, it is one of the handiest tools in my toolbelt.
It saves me from having to write nasty, tangled, and flaky integration tests.
Without behavioral abstractions, systems are doomed to be tightly coupled and loosely tested.</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2024
Andrew Dailey
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>