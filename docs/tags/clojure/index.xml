<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Clojure on Shallow Brook Software</title><link>https://shallowbrooksoftware.com/tags/clojure/</link><description>Recent content in Clojure on Shallow Brook Software</description><generator>Hugo</generator><language>en</language><lastBuildDate>Sun, 29 Sep 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://shallowbrooksoftware.com/tags/clojure/index.xml" rel="self" type="application/rss+xml"/><item><title>2025: The Year of Clojure?</title><link>https://shallowbrooksoftware.com/posts/2025-the-year-of-clojure/</link><pubDate>Sun, 29 Sep 2024 00:00:00 +0000</pubDate><guid>https://shallowbrooksoftware.com/posts/2025-the-year-of-clojure/</guid><description>&lt;p>I’ve been thinking about &lt;a href="https://clojure.org/" class="external-link" target="_blank" rel="noopener">Clojure&lt;/a> a lot lately.
Something about this “immutable, data-driven lisp on the JVM” has always fascinated me… but has never “clicked”.
I love its core ideas: immutable data, simple syntax, emphasis on pure functions, great interop with Java, etc.
In fact, my &lt;a href="https://shallowbrooksoftware.com/posts/a-better-pattern-for-go-http-handlers/" >modern patterns&lt;/a> for writing web apps in Go are slowly converging on a more functional design (using higher-order function to close around dependencies).
I’d like to write more Clojure in 2025 and see if I can finally connect deeply with its philosophy.&lt;/p></description></item></channel></rss>