<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go on Shallow Brook Software</title><link>https://shallowbrooksoftware.com/tags/go/</link><description>Recent content in Go on Shallow Brook Software</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 18 Feb 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://shallowbrooksoftware.com/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>My Current Opinions on Hosting Web Apps</title><link>https://shallowbrooksoftware.com/posts/my-current-opinions-on-hosting-web-apps/</link><pubDate>Sun, 18 Feb 2024 00:00:00 +0000</pubDate><guid>https://shallowbrooksoftware.com/posts/my-current-opinions-on-hosting-web-apps/</guid><description>A little while back, I was chatting with some tech friends about my experience using Fly and Neon for hosting web apps that are under active development. Between these two services and their low pricing for small projects, my total bill for the month was only $0.01 (Fly doesn&amp;rsquo;t even collect invoices below $5.00). I shared how Fly and Neon seemed like a great fit for projects that are a work in progress but that I&amp;rsquo;m not sure if I&amp;rsquo;d use them for production services.</description></item><item><title>Utilizing All Cores in a NodeJS Web Application</title><link>https://shallowbrooksoftware.com/posts/utilizing-all-cores-in-a-nodejs-web-application/</link><pubDate>Sun, 28 Jan 2024 00:00:00 +0000</pubDate><guid>https://shallowbrooksoftware.com/posts/utilizing-all-cores-in-a-nodejs-web-application/</guid><description>Coming from Go-based web development to NodeJS, one big thing surpised me: my web server only ever uses one core. This is because NodeJS is a single-threaded runtime environment. That being said, NodeJS is still highly concurrent: it uses modern event loop technology to implement non-blocking, IO-based concurrency. NodeJS might not be truly parallel, but it is certainly concurrent. Knowing this, how is it that NodeJS performs reasonably well in server-side environments?</description></item><item><title>Implementing Make in Go</title><link>https://shallowbrooksoftware.com/posts/implementing-make-in-go/</link><pubDate>Sun, 14 Jan 2024 00:00:00 +0000</pubDate><guid>https://shallowbrooksoftware.com/posts/implementing-make-in-go/</guid><description>A while back, my buddy Wes and I took a weekend trip to a remote cabin in eastern Iowa. We try to do this once a year with plans of fishing, hiking, and simply enjoying the quietness of nature. Not to mention the bliss of having no responsibilities for a few days! Despite being an outdoorsy trip, I still brought my laptop because programming is my favorite hobby. The internet in such remote locations is typically unreliable so I still consider it to be a nice disconnect.</description></item><item><title>Learning From geohot's minikeyvalue Project</title><link>https://shallowbrooksoftware.com/posts/learning-from-geohots-minikeyvalue-project/</link><pubDate>Thu, 14 Jan 2021 00:00:00 +0000</pubDate><guid>https://shallowbrooksoftware.com/posts/learning-from-geohots-minikeyvalue-project/</guid><description>I first became aware of minikeyvalue while watching a recording of George&amp;rsquo;s programming livestream. This project was written in Python and the design was simple: an HTTP-based interface for storing, getting, and deleting arbitrary content. Many folks call this type of thing a &amp;ldquo;distributed key-value store&amp;rdquo;. The project was originally inspired by SeaweedFS but had the goal of being much, much simpler (ideally less than 1000 lines of code).
The architecture of the program is straightforward: a single &amp;ldquo;index server&amp;rdquo; distributes and organizes data between any number of &amp;ldquo;volume servers&amp;rdquo;.</description></item></channel></rss>