<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go on Shallow Brook Software</title><link>https://shallowbrooksoftware.com/tags/go/</link><description>Recent content in Go on Shallow Brook Software</description><generator>Hugo</generator><language>en</language><lastBuildDate>Sun, 21 Apr 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://shallowbrooksoftware.com/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>Limiting Concurrency with Semaphores</title><link>https://shallowbrooksoftware.com/posts/limiting-concurrency-with-semaphores/</link><pubDate>Sun, 21 Apr 2024 00:00:00 +0000</pubDate><guid>https://shallowbrooksoftware.com/posts/limiting-concurrency-with-semaphores/</guid><description>I recently encountered some slowness while executing a bunch of tasks within a program. Specifically, I was working on how Bloggulus syncs all of the blogs that it tracks (there are only 40 or so right now but I expect the number to grow). Instead of naively syncing each blog serially, maybe concurrency can help. Let&amp;rsquo;s find some ways to speed it up!
Serial Link to heading As a baseline, consider this simple program that executes multiple tasks in sequence.</description></item><item><title>Simple REST API Pagination</title><link>https://shallowbrooksoftware.com/posts/simple-rest-api-pagination/</link><pubDate>Sun, 14 Apr 2024 22:00:00 +0000</pubDate><guid>https://shallowbrooksoftware.com/posts/simple-rest-api-pagination/</guid><description>Recently, I&amp;rsquo;ve been working on revamping my Bloggulus project to a split REST API + SPA architecture (for fun and as an excuse to learn SvelteKit). As a part of this effort, I took a moment to research and revisit how the API handles pagination. Since the system holds hundreds of blogs and thousands of posts, returning all items from a request would be slow and unwieldy. Instead, the user (or web frontend) should be allowed to specify which set of items they want to view.</description></item><item><title>Instrumenting Go Web Apps</title><link>https://shallowbrooksoftware.com/posts/instrumenting-go-web-apps/</link><pubDate>Sun, 07 Apr 2024 23:00:00 +0000</pubDate><guid>https://shallowbrooksoftware.com/posts/instrumenting-go-web-apps/</guid><description>Prometheus is an incredible open-source system for collecting, storing, and analyzing system metrics. In addition to the server program, numerous client libraries have been written to simplify the process of exposing metrics in your own projects. When writing Go-based web apps, I always include Go&amp;rsquo;s client library so that information about the program can be collected, visualized, and monitored. As outlined in the official guide, it is very easy to get these basic metrics up and running:</description></item><item><title>Testing with Transactions</title><link>https://shallowbrooksoftware.com/posts/testing-with-transactions/</link><pubDate>Sun, 24 Mar 2024 00:00:00 +0000</pubDate><guid>https://shallowbrooksoftware.com/posts/testing-with-transactions/</guid><description>Most web applications eventually end up with tests that need to interact with a database. Perhaps your business logic is tightly coupled to the database or maybe you are wanting to test a clearly-defined storage layer. Either way, a common problem arises: how do you clean up the data used during testing? What should you do with all those scattered rows?
Most of the time, developers will resort to a few common strategies:</description></item><item><title>Conditional Embedding in Go</title><link>https://shallowbrooksoftware.com/posts/conditional-embedding-in-go/</link><pubDate>Sun, 10 Mar 2024 00:00:00 +0000</pubDate><guid>https://shallowbrooksoftware.com/posts/conditional-embedding-in-go/</guid><description>I was recently working on a project where the frontend is a Svelte SPA and the backend is a Go REST API. At a high level, this is how my project is structured:
main.go backend/ # source files for Go REST API frontend/ package.json src/ # source files for Svelte SPA Since Go is awesome, I&amp;rsquo;ve been using its embed feature to bake all of the compiled frontend files into the single output binary.</description></item><item><title>My Current Opinions on Hosting Web Apps</title><link>https://shallowbrooksoftware.com/posts/my-current-opinions-on-hosting-web-apps/</link><pubDate>Sun, 18 Feb 2024 00:00:00 +0000</pubDate><guid>https://shallowbrooksoftware.com/posts/my-current-opinions-on-hosting-web-apps/</guid><description>A little while back, I was chatting with some tech friends about my experience using Fly and Neon for hosting web apps that are under active development. Between these two services and their low pricing for small projects, my total bill for the month was only $0.01 (Fly doesn&amp;rsquo;t even collect invoices below $5.00). I shared how Fly and Neon seemed like a great fit for projects that are a work in progress but that I&amp;rsquo;m not sure if I&amp;rsquo;d use them for production services.</description></item><item><title>Utilizing All Cores in a NodeJS Web Application</title><link>https://shallowbrooksoftware.com/posts/utilizing-all-cores-in-a-nodejs-web-application/</link><pubDate>Sun, 28 Jan 2024 00:00:00 +0000</pubDate><guid>https://shallowbrooksoftware.com/posts/utilizing-all-cores-in-a-nodejs-web-application/</guid><description>Coming from Go-based web development to NodeJS, one big thing surpised me: my web server only ever uses one core. This is because NodeJS is a single-threaded runtime environment. That being said, NodeJS is still highly concurrent: it uses modern event loop technology to implement non-blocking, IO-based concurrency. NodeJS might not be truly parallel, but it is certainly concurrent. Knowing this, how is it that NodeJS performs reasonably well in server-side environments?</description></item><item><title>Implementing Make in Go</title><link>https://shallowbrooksoftware.com/posts/implementing-make-in-go/</link><pubDate>Sun, 14 Jan 2024 00:00:00 +0000</pubDate><guid>https://shallowbrooksoftware.com/posts/implementing-make-in-go/</guid><description>A while back, my buddy Wes and I took a weekend trip to a remote cabin in eastern Iowa. We try to do this once a year with plans of fishing, hiking, and simply enjoying the quietness of nature. Not to mention the bliss of having no responsibilities for a few days! Despite being an outdoorsy trip, I still brought my laptop because programming is my favorite hobby. The internet in such remote locations is typically unreliable so I still consider it to be a nice disconnect.</description></item><item><title>Learning From geohot's minikeyvalue Project</title><link>https://shallowbrooksoftware.com/posts/learning-from-geohots-minikeyvalue-project/</link><pubDate>Thu, 14 Jan 2021 00:00:00 +0000</pubDate><guid>https://shallowbrooksoftware.com/posts/learning-from-geohots-minikeyvalue-project/</guid><description>I first became aware of minikeyvalue while watching a recording of George&amp;rsquo;s programming livestream. This project was written in Python and the design was simple: an HTTP-based interface for storing, getting, and deleting arbitrary content. Many folks call this type of thing a &amp;ldquo;distributed key-value store&amp;rdquo;. The project was originally inspired by SeaweedFS but had the goal of being much, much simpler (ideally less than 1000 lines of code).
The architecture of the program is straightforward: a single &amp;ldquo;index server&amp;rdquo; distributes and organizes data between any number of &amp;ldquo;volume servers&amp;rdquo;.</description></item></channel></rss>